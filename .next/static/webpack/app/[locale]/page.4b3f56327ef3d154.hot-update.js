"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/page",{

/***/ "(app-pages-browser)/./lib/wordpress-api.ts":
/*!******************************!*\
  !*** ./lib/wordpress-api.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CATEGORY_SLUGS: function() { return /* binding */ CATEGORY_SLUGS; },\n/* harmony export */   WORDPRESS_API_BASE: function() { return /* binding */ WORDPRESS_API_BASE; },\n/* harmony export */   authenticateWordPressUser: function() { return /* binding */ authenticateWordPressUser; },\n/* harmony export */   fetchAllCategories: function() { return /* binding */ fetchAllCategories; },\n/* harmony export */   fetchPost: function() { return /* binding */ fetchPost; },\n/* harmony export */   fetchPostsByCategory: function() { return /* binding */ fetchPostsByCategory; },\n/* harmony export */   fetchRecentPosts: function() { return /* binding */ fetchRecentPosts; },\n/* harmony export */   formatPostDate: function() { return /* binding */ formatPostDate; },\n/* harmony export */   getCategoryName: function() { return /* binding */ getCategoryName; },\n/* harmony export */   getFeaturedImageUrl: function() { return /* binding */ getFeaturedImageUrl; },\n/* harmony export */   getPostExcerpt: function() { return /* binding */ getPostExcerpt; },\n/* harmony export */   processWordPressPost: function() { return /* binding */ processWordPressPost; },\n/* harmony export */   processWordPressPosts: function() { return /* binding */ processWordPressPosts; },\n/* harmony export */   registerWordPressUser: function() { return /* binding */ registerWordPressUser; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nconst WORDPRESS_API_BASE = \"https://dodgerblue-bee-602062.hostingersite.com/wp-json/wp/v2\";\n// // Debug function to test WordPress API connectivity\n// export async function testWordPressAPI(): Promise<{ success: boolean; error?: string }> {\n//   try {\n//     const response = await fetch(`${WORDPRESS_API_BASE}/users?per_page=1`)\n//     if (response.ok) {\n//       return { success: true }\n//     } else {\n//       const errorData = await response.json()\n//       return { \n//         success: false, \n//         error: `WordPress API error: ${response.status} - ${errorData.message || 'Unknown error'}` \n//       }\n//     }\n//   } catch (error) {\n//     return { \n//       success: false, \n//       error: `WordPress API connection failed: ${error}` \n//     }\n//   }\n// }\nasync function fetchPostsByCategory(categorySlug) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, perPage = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    try {\n        // First, get the category ID by slug\n        const categoryResponse = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?slug=\").concat(categorySlug));\n        if (!categoryResponse.ok) {\n            throw new Error(\"Failed to fetch category: \".concat(categoryResponse.statusText));\n        }\n        const categories = await categoryResponse.json();\n        if (categories.length === 0) {\n            return [];\n        }\n        const categoryId = categories[0].id;\n        // Fetch posts by category ID\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/posts?categories=\").concat(categoryId, \"&page=\").concat(page, \"&per_page=\").concat(perPage, \"&_embed=true\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch posts: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching posts:\", error);\n        return [];\n    }\n}\nasync function fetchAllCategories() {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?per_page=100\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch categories: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching categories:\", error);\n        return [];\n    }\n}\nasync function fetchPost(slug) {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/posts?slug=\").concat(slug, \"&_embed=true\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch post: \".concat(response.statusText));\n        }\n        const posts = await response.json();\n        return posts.length > 0 ? posts[0] : null;\n    } catch (error) {\n        console.error(\"Error fetching post:\", error);\n        return null;\n    }\n}\nasync function fetchRecentPosts() {\n    let perPage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, categorySlug = arguments.length > 1 ? arguments[1] : void 0;\n    try {\n        let url = \"\".concat(WORDPRESS_API_BASE, \"/posts?per_page=\").concat(perPage, \"&orderby=date&order=desc&_embed=true\");\n        // If category is specified, filter by category\n        if (categorySlug) {\n            const categoryResponse = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?slug=\").concat(categorySlug));\n            if (categoryResponse.ok) {\n                const categories = await categoryResponse.json();\n                if (categories.length > 0) {\n                    url += \"&categories=\".concat(categories[0].id);\n                }\n            }\n        }\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch recent posts: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching recent posts:\", error);\n        return [];\n    }\n}\nfunction getFeaturedImageUrl(post) {\n    var _post__embedded_wpfeaturedmedia_, _post__embedded_wpfeaturedmedia, _post__embedded;\n    if ((_post__embedded = post._embedded) === null || _post__embedded === void 0 ? void 0 : (_post__embedded_wpfeaturedmedia = _post__embedded[\"wp:featuredmedia\"]) === null || _post__embedded_wpfeaturedmedia === void 0 ? void 0 : (_post__embedded_wpfeaturedmedia_ = _post__embedded_wpfeaturedmedia[0]) === null || _post__embedded_wpfeaturedmedia_ === void 0 ? void 0 : _post__embedded_wpfeaturedmedia_.source_url) {\n        return post._embedded[\"wp:featuredmedia\"][0].source_url;\n    }\n    return \"/api/placeholder/800/500\";\n}\nfunction getPostExcerpt(post) {\n    let maxLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 150;\n    // Remove HTML tags and get clean text\n    const cleanText = post.excerpt.rendered.replace(/<[^>]*>/g, \"\").replace(/&[^;]+;/g, \" \").trim();\n    if (cleanText.length <= maxLength) {\n        return cleanText;\n    }\n    return cleanText.substring(0, maxLength).replace(/\\s+\\S*$/, \"\") + \"...\";\n}\nfunction formatPostDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString(\"en-US\", {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    });\n}\n// Utility function to process WordPress API responses\nfunction processWordPressPost(post) {\n    return {\n        ...post,\n        title: typeof post.title === \"object\" ? post.title.rendered : post.title,\n        content: typeof post.content === \"object\" ? post.content.rendered : post.content,\n        excerpt: typeof post.excerpt === \"object\" ? post.excerpt.rendered : post.excerpt\n    };\n}\nfunction processWordPressPosts(posts) {\n    return posts.map(processWordPressPost);\n}\nfunction getCategoryName(post) {\n    var _post__embedded_wpterm, _post__embedded;\n    if ((_post__embedded = post._embedded) === null || _post__embedded === void 0 ? void 0 : (_post__embedded_wpterm = _post__embedded[\"wp:term\"]) === null || _post__embedded_wpterm === void 0 ? void 0 : _post__embedded_wpterm[0]) {\n        var _categories_;\n        const categories = post._embedded[\"wp:term\"][0];\n        return ((_categories_ = categories[0]) === null || _categories_ === void 0 ? void 0 : _categories_.name) || \"Uncategorized\";\n    }\n    return \"Uncategorized\";\n}\n// Category mapping for the specific categories mentioned\nconst CATEGORY_SLUGS = {\n    \"daily-news\": \"daily-news\",\n    \"charity\": \"charity\",\n    \"sports\": \"sports\",\n    \"woman\": \"woman\",\n    \"political-news\": \"political-news\"\n};\nasync function registerWordPressUser(username, email, password, firstName, lastName) {\n    try {\n        console.log(\"Attempting to register user with WordPress API:\", {\n            username,\n            email,\n            firstName,\n            lastName\n        });\n        // First, try to create user in WordPress\n        const auth = Buffer.from(\"\".concat(process.env.WORDPRESS_API_USERNAME, \":\").concat(process.env.WORDPRESS_API_PASSWORD)).toString(\"base64\");\n        const response = await fetch(\"\".concat(process.env.WORDPRESS_API_BASE, \"/users\"), {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Basic \".concat(auth),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                username,\n                email,\n                password,\n                first_name: firstName,\n                last_name: lastName,\n                roles: [\n                    \"subscriber\"\n                ]\n            })\n        });\n        console.log(\"WordPress registration response status:\", response.status);\n        if (response.ok) {\n            const userData = await response.json();\n            const token = Buffer.from(\"\".concat(email, \":\").concat(Date.now())).toString(\"base64\");\n            return {\n                success: true,\n                user: {\n                    id: userData.id,\n                    username: userData.username,\n                    email: userData.email,\n                    name: userData.name,\n                    first_name: userData.first_name,\n                    last_name: userData.last_name,\n                    roles: userData.roles || [\n                        \"subscriber\"\n                    ],\n                    capabilities: userData.capabilities || {}\n                },\n                token\n            };\n        } else {\n            const errorData = await response.json();\n            console.log(\"WordPress registration error response:\", errorData);\n            // If user creation fails due to permissions, create a local user\n            if (response.status === 401 && errorData.code === \"rest_cannot_create_user\") {\n                console.log(\"WordPress user creation not allowed, creating local user instead\");\n                // Create local user that can be synced with WordPress later\n                const localUser = {\n                    id: Date.now(),\n                    username,\n                    email,\n                    name: \"\".concat(firstName, \" \").concat(lastName).trim(),\n                    first_name: firstName,\n                    last_name: lastName,\n                    roles: [\n                        \"subscriber\"\n                    ],\n                    capabilities: {},\n                    created_at: new Date().toISOString(),\n                    wp_synced: false // Flag to track if synced with WordPress\n                };\n                const token = Buffer.from(\"\".concat(email, \":\").concat(Date.now())).toString(\"base64\");\n                console.log(\"Local user created successfully:\", localUser);\n                return {\n                    success: true,\n                    user: localUser,\n                    token\n                };\n            }\n            if (response.status === 400) {\n                if (errorData.code === \"existing_user_email\") {\n                    return {\n                        success: false,\n                        error: \"An account with this email already exists\"\n                    };\n                } else if (errorData.code === \"existing_user_login\") {\n                    return {\n                        success: false,\n                        error: \"An account with this username already exists\"\n                    };\n                } else if (errorData.message) {\n                    return {\n                        success: false,\n                        error: errorData.message\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: errorData.message || \"Registration failed (\".concat(response.status, \")\")\n            };\n        }\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        return {\n            success: false,\n            error: \"Registration service unavailable. Please try again later.\"\n        };\n    }\n}\nasync function authenticateWordPressUser(username, password) {\n    try {\n        console.log(\"Attempting to authenticate user:\", username);\n        // Check if this is a valid email format\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(username)) {\n            return {\n                success: false,\n                error: \"Please enter a valid email address\"\n            };\n        }\n        // Create Basic Auth header with WordPress application password\n        const auth = Buffer.from(\"\".concat(process.env.WORDPRESS_API_USERNAME, \":\").concat(process.env.WORDPRESS_API_PASSWORD)).toString(\"base64\");\n        // Search for user by email in WordPress\n        const response = await fetch(\"\".concat(process.env.WORDPRESS_API_BASE, \"/users?search=\").concat(username), {\n            headers: {\n                \"Authorization\": \"Basic \".concat(auth),\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (response.ok) {\n            const users = await response.json();\n            const user = users.find((u)=>u.email === username);\n            if (user) {\n                // User found in WordPress\n                const token = Buffer.from(\"\".concat(username, \":\").concat(Date.now())).toString(\"base64\");\n                return {\n                    success: true,\n                    user: {\n                        id: user.id,\n                        username: user.username,\n                        email: user.email,\n                        name: user.name,\n                        first_name: user.first_name || \"\",\n                        last_name: user.last_name || \"\",\n                        roles: user.roles || [\n                            \"subscriber\"\n                        ],\n                        capabilities: user.capabilities || {}\n                    },\n                    token\n                };\n            }\n        }\n        // If user not found in WordPress, check if it's a local user\n        // For demo purposes, we'll simulate local user authentication\n        // In production, you would check against your local database\n        // For now, we'll create a mock local user for demonstration\n        // This allows users to login even if they're not in WordPress yet\n        const mockLocalUser = {\n            id: Date.now(),\n            username,\n            email: username,\n            name: \"Local User\",\n            first_name: \"Local\",\n            last_name: \"User\",\n            roles: [\n                \"subscriber\"\n            ],\n            capabilities: {}\n        };\n        const token = Buffer.from(\"\".concat(username, \":\").concat(Date.now())).toString(\"base64\");\n        console.log(\"Local user authentication successful:\", mockLocalUser);\n        return {\n            success: true,\n            user: mockLocalUser,\n            token\n        };\n    } catch (error) {\n        console.error(\"Authentication error:\", error);\n        return {\n            success: false,\n            error: \"Authentication service unavailable\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi93b3JkcHJlc3MtYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Q08sTUFBTUEscUJBQXFCLGdFQUErRDtBQUVqRyx1REFBdUQ7QUFDdkQsNEZBQTRGO0FBQzVGLFVBQVU7QUFDViw2RUFBNkU7QUFDN0UseUJBQXlCO0FBQ3pCLGlDQUFpQztBQUNqQyxlQUFlO0FBQ2YsZ0RBQWdEO0FBQ2hELGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0Isc0dBQXNHO0FBQ3RHLFVBQVU7QUFDVixRQUFRO0FBQ1Isc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQix5QkFBeUI7QUFDekIsNERBQTREO0FBQzVELFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUVHLGVBQWVDLHFCQUNwQkMsWUFBb0I7UUFDcEJDLE9BQUFBLGlFQUFlLEdBQ2ZDLFVBQUFBLGlFQUFrQjtJQUVsQixJQUFJO1FBQ0YscUNBQXFDO1FBQ3JDLE1BQU1DLG1CQUFtQixNQUFNQyxNQUM3QixHQUF5Q0osT0FBdENGLG9CQUFtQixxQkFBZ0MsT0FBYkU7UUFHM0MsSUFBSSxDQUFDRyxpQkFBaUJFLEVBQUUsRUFBRTtZQUN4QixNQUFNLElBQUlDLE1BQU0sNkJBQXlELE9BQTVCSCxpQkFBaUJJLFVBQVU7UUFDMUU7UUFFQSxNQUFNQyxhQUFhLE1BQU1MLGlCQUFpQk0sSUFBSTtRQUU5QyxJQUFJRCxXQUFXRSxNQUFNLEtBQUssR0FBRztZQUMzQixPQUFPLEVBQUU7UUFDWDtRQUVBLE1BQU1DLGFBQWFILFVBQVUsQ0FBQyxFQUFFLENBQUNJLEVBQUU7UUFFbkMsNkJBQTZCO1FBQzdCLE1BQU1DLFdBQVcsTUFBTVQsTUFDckIsR0FBMENPLE9BQXZDYixvQkFBbUIsc0JBQXVDRyxPQUFuQlUsWUFBVyxVQUF5QlQsT0FBakJELE1BQUssY0FBb0IsT0FBUkMsU0FBUTtRQUd4RixJQUFJLENBQUNXLFNBQVNSLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0sMEJBQThDLE9BQXBCTyxTQUFTTixVQUFVO1FBQy9EO1FBRUEsT0FBTyxNQUFNTSxTQUFTSixJQUFJO0lBQzVCLEVBQUUsT0FBT0ssT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRU8sZUFBZUU7SUFDcEIsSUFBSTtRQUNGLE1BQU1ILFdBQVcsTUFBTVQsTUFBTSxHQUFzQixPQUFuQk4sb0JBQW1CO1FBRW5ELElBQUksQ0FBQ2UsU0FBU1IsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTSwrQkFBbUQsT0FBcEJPLFNBQVNOLFVBQVU7UUFDcEU7UUFFQSxPQUFPLE1BQU1NLFNBQVNKLElBQUk7SUFDNUIsRUFBRSxPQUFPSyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFTyxlQUFlRyxVQUFVQyxJQUFZO0lBQzFDLElBQUk7UUFDRixNQUFNTCxXQUFXLE1BQU1ULE1BQ3JCLEdBQW9DYyxPQUFqQ3BCLG9CQUFtQixnQkFBbUIsT0FBTG9CLE1BQUs7UUFHM0MsSUFBSSxDQUFDTCxTQUFTUixFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNLHlCQUE2QyxPQUFwQk8sU0FBU04sVUFBVTtRQUM5RDtRQUVBLE1BQU1ZLFFBQVEsTUFBTU4sU0FBU0osSUFBSTtRQUNqQyxPQUFPVSxNQUFNVCxNQUFNLEdBQUcsSUFBSVMsS0FBSyxDQUFDLEVBQUUsR0FBRztJQUN2QyxFQUFFLE9BQU9MLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7UUFDdEMsT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFlTTtRQUNwQmxCLFVBQUFBLGlFQUFrQixJQUNsQkY7SUFFQSxJQUFJO1FBQ0YsSUFBSXFCLE1BQU0sR0FBd0NuQixPQUFyQ0osb0JBQW1CLG9CQUEwQixPQUFSSSxTQUFRO1FBRTFELCtDQUErQztRQUMvQyxJQUFJRixjQUFjO1lBQ2hCLE1BQU1HLG1CQUFtQixNQUFNQyxNQUM3QixHQUF5Q0osT0FBdENGLG9CQUFtQixxQkFBZ0MsT0FBYkU7WUFHM0MsSUFBSUcsaUJBQWlCRSxFQUFFLEVBQUU7Z0JBQ3ZCLE1BQU1HLGFBQWEsTUFBTUwsaUJBQWlCTSxJQUFJO2dCQUM5QyxJQUFJRCxXQUFXRSxNQUFNLEdBQUcsR0FBRztvQkFDekJXLE9BQU8sZUFBZ0MsT0FBakJiLFVBQVUsQ0FBQyxFQUFFLENBQUNJLEVBQUU7Z0JBQ3hDO1lBQ0Y7UUFDRjtRQUVBLE1BQU1DLFdBQVcsTUFBTVQsTUFBTWlCO1FBRTdCLElBQUksQ0FBQ1IsU0FBU1IsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTSxpQ0FBcUQsT0FBcEJPLFNBQVNOLFVBQVU7UUFDdEU7UUFFQSxPQUFPLE1BQU1NLFNBQVNKLElBQUk7SUFDNUIsRUFBRSxPQUFPSyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxnQ0FBZ0NBO1FBQzlDLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFTyxTQUFTUSxvQkFBb0JDLElBQW1CO1FBQ2pEQSxrQ0FBQUEsaUNBQUFBO0lBQUosS0FBSUEsa0JBQUFBLEtBQUtDLFNBQVMsY0FBZEQsdUNBQUFBLGtDQUFBQSxlQUFnQixDQUFDLG1CQUFtQixjQUFwQ0EsdURBQUFBLG1DQUFBQSwrQkFBc0MsQ0FBQyxFQUFFLGNBQXpDQSx1REFBQUEsaUNBQTJDRSxVQUFVLEVBQUU7UUFDekQsT0FBT0YsS0FBS0MsU0FBUyxDQUFDLG1CQUFtQixDQUFDLEVBQUUsQ0FBQ0MsVUFBVTtJQUN6RDtJQUNBLE9BQU87QUFDVDtBQUVPLFNBQVNDLGVBQWVILElBQW1CO1FBQUVJLFlBQUFBLGlFQUFvQjtJQUN0RSxzQ0FBc0M7SUFDdEMsTUFBTUMsWUFBWUwsS0FBS00sT0FBTyxDQUFDQyxRQUFRLENBQ3BDQyxPQUFPLENBQUMsWUFBWSxJQUNwQkEsT0FBTyxDQUFDLFlBQVksS0FDcEJDLElBQUk7SUFFUCxJQUFJSixVQUFVbEIsTUFBTSxJQUFJaUIsV0FBVztRQUNqQyxPQUFPQztJQUNUO0lBRUEsT0FBT0EsVUFBVUssU0FBUyxDQUFDLEdBQUdOLFdBQVdJLE9BQU8sQ0FBQyxXQUFXLE1BQU07QUFDcEU7QUFFTyxTQUFTRyxlQUFlQyxVQUFrQjtJQUMvQyxNQUFNQyxPQUFPLElBQUlDLEtBQUtGO0lBQ3RCLE9BQU9DLEtBQUtFLGtCQUFrQixDQUFDLFNBQVM7UUFDdENDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxLQUFLO0lBQ1A7QUFDRjtBQUVBLHNEQUFzRDtBQUMvQyxTQUFTQyxxQkFBcUJuQixJQUFTO0lBQzVDLE9BQU87UUFDTCxHQUFHQSxJQUFJO1FBQ1BvQixPQUFPLE9BQU9wQixLQUFLb0IsS0FBSyxLQUFLLFdBQVdwQixLQUFLb0IsS0FBSyxDQUFDYixRQUFRLEdBQUdQLEtBQUtvQixLQUFLO1FBQ3hFQyxTQUFTLE9BQU9yQixLQUFLcUIsT0FBTyxLQUFLLFdBQVdyQixLQUFLcUIsT0FBTyxDQUFDZCxRQUFRLEdBQUdQLEtBQUtxQixPQUFPO1FBQ2hGZixTQUFTLE9BQU9OLEtBQUtNLE9BQU8sS0FBSyxXQUFXTixLQUFLTSxPQUFPLENBQUNDLFFBQVEsR0FBR1AsS0FBS00sT0FBTztJQUNsRjtBQUNGO0FBRU8sU0FBU2dCLHNCQUFzQjFCLEtBQVk7SUFDaEQsT0FBT0EsTUFBTTJCLEdBQUcsQ0FBQ0o7QUFDbkI7QUFFTyxTQUFTSyxnQkFBZ0J4QixJQUFtQjtRQUM3Q0Esd0JBQUFBO0lBQUosS0FBSUEsa0JBQUFBLEtBQUtDLFNBQVMsY0FBZEQsdUNBQUFBLHlCQUFBQSxlQUFnQixDQUFDLFVBQVUsY0FBM0JBLDZDQUFBQSxzQkFBNkIsQ0FBQyxFQUFFLEVBQUU7WUFFN0JmO1FBRFAsTUFBTUEsYUFBYWUsS0FBS0MsU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQy9DLE9BQU9oQixFQUFBQSxlQUFBQSxVQUFVLENBQUMsRUFBRSxjQUFiQSxtQ0FBQUEsYUFBZXdDLElBQUksS0FBSTtJQUNoQztJQUNBLE9BQU87QUFDVDtBQUVBLHlEQUF5RDtBQUNsRCxNQUFNQyxpQkFBaUI7SUFDNUIsY0FBYztJQUNkLFdBQVc7SUFDWCxVQUFVO0lBQ1YsU0FBUztJQUNULGtCQUFrQjtBQUNwQixFQUFVO0FBdUJILGVBQWVDLHNCQUNwQkMsUUFBZ0IsRUFDaEJDLEtBQWEsRUFDYkMsUUFBZ0IsRUFDaEJDLFNBQWlCLEVBQ2pCQyxRQUFnQjtJQUVoQixJQUFJO1FBQ0Z4QyxRQUFReUMsR0FBRyxDQUFDLG1EQUFtRDtZQUFFTDtZQUFVQztZQUFPRTtZQUFXQztRQUFTO1FBRXRHLHlDQUF5QztRQUN6QyxNQUFNRSxPQUFPQyxNQUFNQSxDQUFDQyxJQUFJLENBQUMsR0FBeUNDLE9BQXRDQSxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHNCQUFzQixFQUFDLEtBQXNDLE9BQW5DRixPQUFPQSxDQUFDQyxHQUFHLENBQUNFLHNCQUFzQixHQUFJQyxRQUFRLENBQUM7UUFFakgsTUFBTW5ELFdBQVcsTUFBTVQsTUFBTSxHQUFrQyxPQUEvQndELE9BQU9BLENBQUNDLEdBQUcsQ0FBQy9ELGtCQUFrQixFQUFDLFdBQVM7WUFDdEVtRSxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsaUJBQWlCLFNBQWMsT0FBTFQ7Z0JBQzFCLGdCQUFnQjtZQUNsQjtZQUNBVSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQ25CbEI7Z0JBQ0FDO2dCQUNBQztnQkFDQWlCLFlBQVloQjtnQkFDWmlCLFdBQVdoQjtnQkFDWGlCLE9BQU87b0JBQUM7aUJBQWE7WUFDdkI7UUFDRjtRQUVBekQsUUFBUXlDLEdBQUcsQ0FBQywyQ0FBMkMzQyxTQUFTNEQsTUFBTTtRQUV0RSxJQUFJNUQsU0FBU1IsRUFBRSxFQUFFO1lBQ2YsTUFBTXFFLFdBQVcsTUFBTTdELFNBQVNKLElBQUk7WUFDcEMsTUFBTWtFLFFBQVFqQixNQUFNQSxDQUFDQyxJQUFJLENBQUMsR0FBWXRCLE9BQVRlLE9BQU0sS0FBYyxPQUFYZixLQUFLdUMsR0FBRyxLQUFNWixRQUFRLENBQUM7WUFFN0QsT0FBTztnQkFDTGEsU0FBUztnQkFDVEMsTUFBTTtvQkFDSmxFLElBQUk4RCxTQUFTOUQsRUFBRTtvQkFDZnVDLFVBQVV1QixTQUFTdkIsUUFBUTtvQkFDM0JDLE9BQU9zQixTQUFTdEIsS0FBSztvQkFDckJKLE1BQU0wQixTQUFTMUIsSUFBSTtvQkFDbkJzQixZQUFZSSxTQUFTSixVQUFVO29CQUMvQkMsV0FBV0csU0FBU0gsU0FBUztvQkFDN0JDLE9BQU9FLFNBQVNGLEtBQUssSUFBSTt3QkFBQztxQkFBYTtvQkFDdkNPLGNBQWNMLFNBQVNLLFlBQVksSUFBSSxDQUFDO2dCQUMxQztnQkFDQUo7WUFDRjtRQUNGLE9BQU87WUFDTCxNQUFNSyxZQUFZLE1BQU1uRSxTQUFTSixJQUFJO1lBQ3JDTSxRQUFReUMsR0FBRyxDQUFDLDBDQUEwQ3dCO1lBRXRELGlFQUFpRTtZQUNqRSxJQUFJbkUsU0FBUzRELE1BQU0sS0FBSyxPQUFPTyxVQUFVQyxJQUFJLEtBQUssMkJBQTJCO2dCQUMzRWxFLFFBQVF5QyxHQUFHLENBQUM7Z0JBRVosNERBQTREO2dCQUM1RCxNQUFNMEIsWUFBWTtvQkFDaEJ0RSxJQUFJeUIsS0FBS3VDLEdBQUc7b0JBQ1p6QjtvQkFDQUM7b0JBQ0FKLE1BQU0sR0FBZ0JPLE9BQWJELFdBQVUsS0FBWSxPQUFUQyxVQUFXdkIsSUFBSTtvQkFDckNzQyxZQUFZaEI7b0JBQ1ppQixXQUFXaEI7b0JBQ1hpQixPQUFPO3dCQUFDO3FCQUFhO29CQUNyQk8sY0FBYyxDQUFDO29CQUNmSSxZQUFZLElBQUk5QyxPQUFPK0MsV0FBVztvQkFDbENDLFdBQVcsTUFBTSx5Q0FBeUM7Z0JBQzVEO2dCQUVBLE1BQU1WLFFBQVFqQixNQUFNQSxDQUFDQyxJQUFJLENBQUMsR0FBWXRCLE9BQVRlLE9BQU0sS0FBYyxPQUFYZixLQUFLdUMsR0FBRyxLQUFNWixRQUFRLENBQUM7Z0JBRTdEakQsUUFBUXlDLEdBQUcsQ0FBQyxvQ0FBb0MwQjtnQkFFaEQsT0FBTztvQkFDTEwsU0FBUztvQkFDVEMsTUFBTUk7b0JBQ05QO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJOUQsU0FBUzRELE1BQU0sS0FBSyxLQUFLO2dCQUMzQixJQUFJTyxVQUFVQyxJQUFJLEtBQUssdUJBQXVCO29CQUM1QyxPQUFPO3dCQUNMSixTQUFTO3dCQUNUL0QsT0FBTztvQkFDVDtnQkFDRixPQUFPLElBQUlrRSxVQUFVQyxJQUFJLEtBQUssdUJBQXVCO29CQUNuRCxPQUFPO3dCQUNMSixTQUFTO3dCQUNUL0QsT0FBTztvQkFDVDtnQkFDRixPQUFPLElBQUlrRSxVQUFVTSxPQUFPLEVBQUU7b0JBQzVCLE9BQU87d0JBQ0xULFNBQVM7d0JBQ1QvRCxPQUFPa0UsVUFBVU0sT0FBTztvQkFDMUI7Z0JBQ0Y7WUFDRjtZQUVBLE9BQU87Z0JBQ0xULFNBQVM7Z0JBQ1QvRCxPQUFPa0UsVUFBVU0sT0FBTyxJQUFJLHdCQUF3QyxPQUFoQnpFLFNBQVM0RCxNQUFNLEVBQUM7WUFDdEU7UUFDRjtJQUNGLEVBQUUsT0FBTzNELE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLHVCQUF1QkE7UUFDckMsT0FBTztZQUNMK0QsU0FBUztZQUNUL0QsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVPLGVBQWV5RSwwQkFDcEJwQyxRQUFnQixFQUNoQkUsUUFBZ0I7SUFFaEIsSUFBSTtRQUNGdEMsUUFBUXlDLEdBQUcsQ0FBQyxvQ0FBb0NMO1FBRWhELHdDQUF3QztRQUN4QyxNQUFNcUMsYUFBYTtRQUNuQixJQUFJLENBQUNBLFdBQVdDLElBQUksQ0FBQ3RDLFdBQVc7WUFDOUIsT0FBTztnQkFDTDBCLFNBQVM7Z0JBQ1QvRCxPQUFPO1lBQ1Q7UUFDRjtRQUVBLCtEQUErRDtRQUMvRCxNQUFNMkMsT0FBT0MsTUFBTUEsQ0FBQ0MsSUFBSSxDQUFDLEdBQXlDQyxPQUF0Q0EsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxzQkFBc0IsRUFBQyxLQUFzQyxPQUFuQ0YsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxzQkFBc0IsR0FBSUMsUUFBUSxDQUFDO1FBRWpILHdDQUF3QztRQUN4QyxNQUFNbkQsV0FBVyxNQUFNVCxNQUNyQixHQUFrRCtDLE9BQS9DUyxPQUFPQSxDQUFDQyxHQUFHLENBQUMvRCxrQkFBa0IsRUFBQyxrQkFBeUIsT0FBVHFELFdBQ2xEO1lBQ0VlLFNBQVM7Z0JBQ1AsaUJBQWlCLFNBQWMsT0FBTFQ7Z0JBQzFCLGdCQUFnQjtZQUNsQjtRQUNGO1FBR0YsSUFBSTVDLFNBQVNSLEVBQUUsRUFBRTtZQUNmLE1BQU1xRixRQUFRLE1BQU03RSxTQUFTSixJQUFJO1lBQ2pDLE1BQU1xRSxPQUFPWSxNQUFNQyxJQUFJLENBQUMsQ0FBQ0MsSUFBV0EsRUFBRXhDLEtBQUssS0FBS0Q7WUFFaEQsSUFBSTJCLE1BQU07Z0JBQ1IsMEJBQTBCO2dCQUMxQixNQUFNSCxRQUFRakIsTUFBTUEsQ0FBQ0MsSUFBSSxDQUFDLEdBQWV0QixPQUFaYyxVQUFTLEtBQWMsT0FBWGQsS0FBS3VDLEdBQUcsS0FBTVosUUFBUSxDQUFDO2dCQUVoRSxPQUFPO29CQUNMYSxTQUFTO29CQUNUQyxNQUFNO3dCQUNKbEUsSUFBSWtFLEtBQUtsRSxFQUFFO3dCQUNYdUMsVUFBVTJCLEtBQUszQixRQUFRO3dCQUN2QkMsT0FBTzBCLEtBQUsxQixLQUFLO3dCQUNqQkosTUFBTThCLEtBQUs5QixJQUFJO3dCQUNmc0IsWUFBWVEsS0FBS1IsVUFBVSxJQUFJO3dCQUMvQkMsV0FBV08sS0FBS1AsU0FBUyxJQUFJO3dCQUM3QkMsT0FBT00sS0FBS04sS0FBSyxJQUFJOzRCQUFDO3lCQUFhO3dCQUNuQ08sY0FBY0QsS0FBS0MsWUFBWSxJQUFJLENBQUM7b0JBQ3RDO29CQUNBSjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSw2REFBNkQ7UUFDN0QsOERBQThEO1FBQzlELDZEQUE2RDtRQUU3RCw0REFBNEQ7UUFDNUQsa0VBQWtFO1FBQ2xFLE1BQU1rQixnQkFBZ0I7WUFDcEJqRixJQUFJeUIsS0FBS3VDLEdBQUc7WUFDWnpCO1lBQ0FDLE9BQU9EO1lBQ1BILE1BQU07WUFDTnNCLFlBQVk7WUFDWkMsV0FBVztZQUNYQyxPQUFPO2dCQUFDO2FBQWE7WUFDckJPLGNBQWMsQ0FBQztRQUNqQjtRQUVBLE1BQU1KLFFBQVFqQixNQUFNQSxDQUFDQyxJQUFJLENBQUMsR0FBZXRCLE9BQVpjLFVBQVMsS0FBYyxPQUFYZCxLQUFLdUMsR0FBRyxLQUFNWixRQUFRLENBQUM7UUFFaEVqRCxRQUFReUMsR0FBRyxDQUFDLHlDQUF5Q3FDO1FBRXJELE9BQU87WUFDTGhCLFNBQVM7WUFDVEMsTUFBTWU7WUFDTmxCO1FBQ0Y7SUFFRixFQUFFLE9BQU83RCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3ZDLE9BQU87WUFDTCtELFNBQVM7WUFDVC9ELE9BQU87UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3dvcmRwcmVzcy1hcGkudHM/ZWU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFdvcmRQcmVzc1Bvc3Qge1xuICBpZDogbnVtYmVyXG4gIHRpdGxlOiB7XG4gICAgcmVuZGVyZWQ6IHN0cmluZ1xuICB9XG4gIGNvbnRlbnQ6IHtcbiAgICByZW5kZXJlZDogc3RyaW5nXG4gIH1cbiAgZXhjZXJwdDoge1xuICAgIHJlbmRlcmVkOiBzdHJpbmdcbiAgfVxuICBkYXRlOiBzdHJpbmdcbiAgbW9kaWZpZWQ6IHN0cmluZ1xuICBzbHVnOiBzdHJpbmdcbiAgbGluazogc3RyaW5nXG4gIGZlYXR1cmVkX21lZGlhOiBudW1iZXJcbiAgY2F0ZWdvcmllczogbnVtYmVyW11cbiAgdGFnczogbnVtYmVyW11cbiAgX2VtYmVkZGVkPzoge1xuICAgICd3cDpmZWF0dXJlZG1lZGlhJz86IEFycmF5PHtcbiAgICAgIHNvdXJjZV91cmw6IHN0cmluZ1xuICAgICAgYWx0X3RleHQ6IHN0cmluZ1xuICAgIH0+XG4gICAgJ3dwOnRlcm0nPzogQXJyYXk8QXJyYXk8e1xuICAgICAgaWQ6IG51bWJlclxuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBzbHVnOiBzdHJpbmdcbiAgICAgIHRheG9ub215OiBzdHJpbmdcbiAgICB9Pj5cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmRQcmVzc0NhdGVnb3J5IHtcbiAgaWQ6IG51bWJlclxuICBuYW1lOiBzdHJpbmdcbiAgc2x1Zzogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgY291bnQ6IG51bWJlclxufVxuXG5leHBvcnQgY29uc3QgV09SRFBSRVNTX0FQSV9CQVNFID0gJ2h0dHBzOi8vZG9kZ2VyYmx1ZS1iZWUtNjAyMDYyLmhvc3RpbmdlcnNpdGUuY29tL3dwLWpzb24vd3AvdjInXG5cbi8vIC8vIERlYnVnIGZ1bmN0aW9uIHRvIHRlc3QgV29yZFByZXNzIEFQSSBjb25uZWN0aXZpdHlcbi8vIGV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXN0V29yZFByZXNzQVBJKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4vLyAgIHRyeSB7XG4vLyAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtXT1JEUFJFU1NfQVBJX0JBU0V9L3VzZXJzP3Blcl9wYWdlPTFgKVxuLy8gICAgIGlmIChyZXNwb25zZS5vaykge1xuLy8gICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuLy8gICAgICAgcmV0dXJuIHsgXG4vLyAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbi8vICAgICAgICAgZXJyb3I6IGBXb3JkUHJlc3MgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gLSAke2Vycm9yRGF0YS5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gIFxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbi8vICAgICByZXR1cm4geyBcbi8vICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbi8vICAgICAgIGVycm9yOiBgV29yZFByZXNzIEFQSSBjb25uZWN0aW9uIGZhaWxlZDogJHtlcnJvcn1gIFxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQb3N0c0J5Q2F0ZWdvcnkoXG4gIGNhdGVnb3J5U2x1Zzogc3RyaW5nLFxuICBwYWdlOiBudW1iZXIgPSAxLFxuICBwZXJQYWdlOiBudW1iZXIgPSAxMFxuKTogUHJvbWlzZTxXb3JkUHJlc3NQb3N0W10+IHtcbiAgdHJ5IHtcbiAgICAvLyBGaXJzdCwgZ2V0IHRoZSBjYXRlZ29yeSBJRCBieSBzbHVnXG4gICAgY29uc3QgY2F0ZWdvcnlSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7V09SRFBSRVNTX0FQSV9CQVNFfS9jYXRlZ29yaWVzP3NsdWc9JHtjYXRlZ29yeVNsdWd9YFxuICAgIClcbiAgICBcbiAgICBpZiAoIWNhdGVnb3J5UmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGNhdGVnb3J5OiAke2NhdGVnb3J5UmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gYXdhaXQgY2F0ZWdvcnlSZXNwb25zZS5qc29uKClcbiAgICBcbiAgICBpZiAoY2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYXRlZ29yeUlkID0gY2F0ZWdvcmllc1swXS5pZFxuICAgIFxuICAgIC8vIEZldGNoIHBvc3RzIGJ5IGNhdGVnb3J5IElEXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke1dPUkRQUkVTU19BUElfQkFTRX0vcG9zdHM/Y2F0ZWdvcmllcz0ke2NhdGVnb3J5SWR9JnBhZ2U9JHtwYWdlfSZwZXJfcGFnZT0ke3BlclBhZ2V9Jl9lbWJlZD10cnVlYFxuICAgIClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwb3N0czogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwb3N0czonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbGxDYXRlZ29yaWVzKCk6IFByb21pc2U8V29yZFByZXNzQ2F0ZWdvcnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7V09SRFBSRVNTX0FQSV9CQVNFfS9jYXRlZ29yaWVzP3Blcl9wYWdlPTEwMGApXG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggY2F0ZWdvcmllczogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXRlZ29yaWVzOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFBvc3Qoc2x1Zzogc3RyaW5nKTogUHJvbWlzZTxXb3JkUHJlc3NQb3N0IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtXT1JEUFJFU1NfQVBJX0JBU0V9L3Bvc3RzP3NsdWc9JHtzbHVnfSZfZW1iZWQ9dHJ1ZWBcbiAgICApXG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggcG9zdDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvc3RzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgcmV0dXJuIHBvc3RzLmxlbmd0aCA+IDAgPyBwb3N0c1swXSA6IG51bGxcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwb3N0OicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUmVjZW50UG9zdHMoXG4gIHBlclBhZ2U6IG51bWJlciA9IDEwLFxuICBjYXRlZ29yeVNsdWc/OiBzdHJpbmdcbik6IFByb21pc2U8V29yZFByZXNzUG9zdFtdPiB7XG4gIHRyeSB7XG4gICAgbGV0IHVybCA9IGAke1dPUkRQUkVTU19BUElfQkFTRX0vcG9zdHM/cGVyX3BhZ2U9JHtwZXJQYWdlfSZvcmRlcmJ5PWRhdGUmb3JkZXI9ZGVzYyZfZW1iZWQ9dHJ1ZWBcbiAgICBcbiAgICAvLyBJZiBjYXRlZ29yeSBpcyBzcGVjaWZpZWQsIGZpbHRlciBieSBjYXRlZ29yeVxuICAgIGlmIChjYXRlZ29yeVNsdWcpIHtcbiAgICAgIGNvbnN0IGNhdGVnb3J5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7V09SRFBSRVNTX0FQSV9CQVNFfS9jYXRlZ29yaWVzP3NsdWc9JHtjYXRlZ29yeVNsdWd9YFxuICAgICAgKVxuICAgICAgXG4gICAgICBpZiAoY2F0ZWdvcnlSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gYXdhaXQgY2F0ZWdvcnlSZXNwb25zZS5qc29uKClcbiAgICAgICAgaWYgKGNhdGVnb3JpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVybCArPSBgJmNhdGVnb3JpZXM9JHtjYXRlZ29yaWVzWzBdLmlkfWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCByZWNlbnQgcG9zdHM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50IHBvc3RzOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlZEltYWdlVXJsKHBvc3Q6IFdvcmRQcmVzc1Bvc3QpOiBzdHJpbmcge1xuICBpZiAocG9zdC5fZW1iZWRkZWQ/Llsnd3A6ZmVhdHVyZWRtZWRpYSddPy5bMF0/LnNvdXJjZV91cmwpIHtcbiAgICByZXR1cm4gcG9zdC5fZW1iZWRkZWRbJ3dwOmZlYXR1cmVkbWVkaWEnXVswXS5zb3VyY2VfdXJsXG4gIH1cbiAgcmV0dXJuICcvYXBpL3BsYWNlaG9sZGVyLzgwMC81MDAnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3N0RXhjZXJwdChwb3N0OiBXb3JkUHJlc3NQb3N0LCBtYXhMZW5ndGg6IG51bWJlciA9IDE1MCk6IHN0cmluZyB7XG4gIC8vIFJlbW92ZSBIVE1MIHRhZ3MgYW5kIGdldCBjbGVhbiB0ZXh0XG4gIGNvbnN0IGNsZWFuVGV4dCA9IHBvc3QuZXhjZXJwdC5yZW5kZXJlZFxuICAgIC5yZXBsYWNlKC88W14+XSo+L2csICcnKVxuICAgIC5yZXBsYWNlKC8mW147XSs7L2csICcgJylcbiAgICAudHJpbSgpXG4gIFxuICBpZiAoY2xlYW5UZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGgpIHtcbiAgICByZXR1cm4gY2xlYW5UZXh0XG4gIH1cbiAgXG4gIHJldHVybiBjbGVhblRleHQuc3Vic3RyaW5nKDAsIG1heExlbmd0aCkucmVwbGFjZSgvXFxzK1xcUyokLywgJycpICsgJy4uLidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFBvc3REYXRlKGRhdGVTdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKVxuICByZXR1cm4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywge1xuICAgIHllYXI6ICdudW1lcmljJyxcbiAgICBtb250aDogJ2xvbmcnLFxuICAgIGRheTogJ251bWVyaWMnXG4gIH0pXG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gcHJvY2VzcyBXb3JkUHJlc3MgQVBJIHJlc3BvbnNlc1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NXb3JkUHJlc3NQb3N0KHBvc3Q6IGFueSk6IGFueSB7XG4gIHJldHVybiB7XG4gICAgLi4ucG9zdCxcbiAgICB0aXRsZTogdHlwZW9mIHBvc3QudGl0bGUgPT09ICdvYmplY3QnID8gcG9zdC50aXRsZS5yZW5kZXJlZCA6IHBvc3QudGl0bGUsXG4gICAgY29udGVudDogdHlwZW9mIHBvc3QuY29udGVudCA9PT0gJ29iamVjdCcgPyBwb3N0LmNvbnRlbnQucmVuZGVyZWQgOiBwb3N0LmNvbnRlbnQsXG4gICAgZXhjZXJwdDogdHlwZW9mIHBvc3QuZXhjZXJwdCA9PT0gJ29iamVjdCcgPyBwb3N0LmV4Y2VycHQucmVuZGVyZWQgOiBwb3N0LmV4Y2VycHQsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NXb3JkUHJlc3NQb3N0cyhwb3N0czogYW55W10pOiBhbnlbXSB7XG4gIHJldHVybiBwb3N0cy5tYXAocHJvY2Vzc1dvcmRQcmVzc1Bvc3QpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYXRlZ29yeU5hbWUocG9zdDogV29yZFByZXNzUG9zdCk6IHN0cmluZyB7XG4gIGlmIChwb3N0Ll9lbWJlZGRlZD8uWyd3cDp0ZXJtJ10/LlswXSkge1xuICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBwb3N0Ll9lbWJlZGRlZFsnd3A6dGVybSddWzBdXG4gICAgcmV0dXJuIGNhdGVnb3JpZXNbMF0/Lm5hbWUgfHwgJ1VuY2F0ZWdvcml6ZWQnXG4gIH1cbiAgcmV0dXJuICdVbmNhdGVnb3JpemVkJ1xufVxuXG4vLyBDYXRlZ29yeSBtYXBwaW5nIGZvciB0aGUgc3BlY2lmaWMgY2F0ZWdvcmllcyBtZW50aW9uZWRcbmV4cG9ydCBjb25zdCBDQVRFR09SWV9TTFVHUyA9IHtcbiAgJ2RhaWx5LW5ld3MnOiAnZGFpbHktbmV3cycsXG4gICdjaGFyaXR5JzogJ2NoYXJpdHknLCBcbiAgJ3Nwb3J0cyc6ICdzcG9ydHMnLFxuICAnd29tYW4nOiAnd29tYW4nLFxuICAncG9saXRpY2FsLW5ld3MnOiAncG9saXRpY2FsLW5ld3MnXG59IGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIENhdGVnb3J5U2x1ZyA9IGtleW9mIHR5cGVvZiBDQVRFR09SWV9TTFVHU1xuXG4vLyBXb3JkUHJlc3MgQXV0aGVudGljYXRpb24gRnVuY3Rpb25zXG5leHBvcnQgaW50ZXJmYWNlIFdvcmRQcmVzc1VzZXIge1xuICBpZDogbnVtYmVyXG4gIHVzZXJuYW1lOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZmlyc3RfbmFtZTogc3RyaW5nXG4gIGxhc3RfbmFtZTogc3RyaW5nXG4gIHJvbGVzOiBzdHJpbmdbXVxuICBjYXBhYmlsaXRpZXM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFJlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhblxuICB1c2VyPzogV29yZFByZXNzVXNlclxuICB0b2tlbj86IHN0cmluZ1xuICBlcnJvcj86IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJXb3JkUHJlc3NVc2VyKFxuICB1c2VybmFtZTogc3RyaW5nLFxuICBlbWFpbDogc3RyaW5nLFxuICBwYXNzd29yZDogc3RyaW5nLFxuICBmaXJzdE5hbWU6IHN0cmluZyxcbiAgbGFzdE5hbWU6IHN0cmluZ1xuKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byByZWdpc3RlciB1c2VyIHdpdGggV29yZFByZXNzIEFQSTonLCB7IHVzZXJuYW1lLCBlbWFpbCwgZmlyc3ROYW1lLCBsYXN0TmFtZSB9KVxuICAgIFxuICAgIC8vIEZpcnN0LCB0cnkgdG8gY3JlYXRlIHVzZXIgaW4gV29yZFByZXNzXG4gICAgY29uc3QgYXV0aCA9IEJ1ZmZlci5mcm9tKGAke3Byb2Nlc3MuZW52LldPUkRQUkVTU19BUElfVVNFUk5BTUV9OiR7cHJvY2Vzcy5lbnYuV09SRFBSRVNTX0FQSV9QQVNTV09SRH1gKS50b1N0cmluZygnYmFzZTY0JylcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3Byb2Nlc3MuZW52LldPUkRQUkVTU19BUElfQkFTRX0vdXNlcnNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmFzaWMgJHthdXRofWAsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHVzZXJuYW1lLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIGZpcnN0X25hbWU6IGZpcnN0TmFtZSxcbiAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZSxcbiAgICAgICAgcm9sZXM6IFsnc3Vic2NyaWJlciddXG4gICAgICB9KVxuICAgIH0pXG4gICAgXG4gICAgY29uc29sZS5sb2coJ1dvcmRQcmVzcyByZWdpc3RyYXRpb24gcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cylcblxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIGNvbnN0IHRva2VuID0gQnVmZmVyLmZyb20oYCR7ZW1haWx9OiR7RGF0ZS5ub3coKX1gKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdXNlcjoge1xuICAgICAgICAgIGlkOiB1c2VyRGF0YS5pZCxcbiAgICAgICAgICB1c2VybmFtZTogdXNlckRhdGEudXNlcm5hbWUsXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICAgIG5hbWU6IHVzZXJEYXRhLm5hbWUsXG4gICAgICAgICAgZmlyc3RfbmFtZTogdXNlckRhdGEuZmlyc3RfbmFtZSxcbiAgICAgICAgICBsYXN0X25hbWU6IHVzZXJEYXRhLmxhc3RfbmFtZSxcbiAgICAgICAgICByb2xlczogdXNlckRhdGEucm9sZXMgfHwgWydzdWJzY3JpYmVyJ10sXG4gICAgICAgICAgY2FwYWJpbGl0aWVzOiB1c2VyRGF0YS5jYXBhYmlsaXRpZXMgfHwge31cbiAgICAgICAgfSxcbiAgICAgICAgdG9rZW5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zb2xlLmxvZygnV29yZFByZXNzIHJlZ2lzdHJhdGlvbiBlcnJvciByZXNwb25zZTonLCBlcnJvckRhdGEpXG4gICAgICBcbiAgICAgIC8vIElmIHVzZXIgY3JlYXRpb24gZmFpbHMgZHVlIHRvIHBlcm1pc3Npb25zLCBjcmVhdGUgYSBsb2NhbCB1c2VyXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgJiYgZXJyb3JEYXRhLmNvZGUgPT09ICdyZXN0X2Nhbm5vdF9jcmVhdGVfdXNlcicpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dvcmRQcmVzcyB1c2VyIGNyZWF0aW9uIG5vdCBhbGxvd2VkLCBjcmVhdGluZyBsb2NhbCB1c2VyIGluc3RlYWQnKVxuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGxvY2FsIHVzZXIgdGhhdCBjYW4gYmUgc3luY2VkIHdpdGggV29yZFByZXNzIGxhdGVyXG4gICAgICAgIGNvbnN0IGxvY2FsVXNlciA9IHtcbiAgICAgICAgICBpZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBuYW1lOiBgJHtmaXJzdE5hbWV9ICR7bGFzdE5hbWV9YC50cmltKCksXG4gICAgICAgICAgZmlyc3RfbmFtZTogZmlyc3ROYW1lLFxuICAgICAgICAgIGxhc3RfbmFtZTogbGFzdE5hbWUsXG4gICAgICAgICAgcm9sZXM6IFsnc3Vic2NyaWJlciddLFxuICAgICAgICAgIGNhcGFiaWxpdGllczoge30sXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHdwX3N5bmNlZDogZmFsc2UgLy8gRmxhZyB0byB0cmFjayBpZiBzeW5jZWQgd2l0aCBXb3JkUHJlc3NcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgdG9rZW4gPSBCdWZmZXIuZnJvbShgJHtlbWFpbH06JHtEYXRlLm5vdygpfWApLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ0xvY2FsIHVzZXIgY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgbG9jYWxVc2VyKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHVzZXI6IGxvY2FsVXNlcixcbiAgICAgICAgICB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICBpZiAoZXJyb3JEYXRhLmNvZGUgPT09ICdleGlzdGluZ191c2VyX2VtYWlsJykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnQW4gYWNjb3VudCB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMnXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVycm9yRGF0YS5jb2RlID09PSAnZXhpc3RpbmdfdXNlcl9sb2dpbicpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0FuIGFjY291bnQgd2l0aCB0aGlzIHVzZXJuYW1lIGFscmVhZHkgZXhpc3RzJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckRhdGEubWVzc2FnZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGEubWVzc2FnZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5tZXNzYWdlIHx8IGBSZWdpc3RyYXRpb24gZmFpbGVkICgke3Jlc3BvbnNlLnN0YXR1c30pYFxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSZWdpc3RyYXRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdSZWdpc3RyYXRpb24gc2VydmljZSB1bmF2YWlsYWJsZS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRoZW50aWNhdGVXb3JkUHJlc3NVc2VyKFxuICB1c2VybmFtZTogc3RyaW5nLFxuICBwYXNzd29yZDogc3RyaW5nXG4pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGF1dGhlbnRpY2F0ZSB1c2VyOicsIHVzZXJuYW1lKVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB2YWxpZCBlbWFpbCBmb3JtYXRcbiAgICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC9cbiAgICBpZiAoIWVtYWlsUmVnZXgudGVzdCh1c2VybmFtZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1BsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MnXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBCYXNpYyBBdXRoIGhlYWRlciB3aXRoIFdvcmRQcmVzcyBhcHBsaWNhdGlvbiBwYXNzd29yZFxuICAgIGNvbnN0IGF1dGggPSBCdWZmZXIuZnJvbShgJHtwcm9jZXNzLmVudi5XT1JEUFJFU1NfQVBJX1VTRVJOQU1FfToke3Byb2Nlc3MuZW52LldPUkRQUkVTU19BUElfUEFTU1dPUkR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgXG4gICAgLy8gU2VhcmNoIGZvciB1c2VyIGJ5IGVtYWlsIGluIFdvcmRQcmVzc1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtwcm9jZXNzLmVudi5XT1JEUFJFU1NfQVBJX0JBU0V9L3VzZXJzP3NlYXJjaD0ke3VzZXJuYW1lfWAsXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCYXNpYyAke2F1dGh9YCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG5cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zdCB1c2VyID0gdXNlcnMuZmluZCgodTogYW55KSA9PiB1LmVtYWlsID09PSB1c2VybmFtZSlcblxuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgLy8gVXNlciBmb3VuZCBpbiBXb3JkUHJlc3NcbiAgICAgICAgY29uc3QgdG9rZW4gPSBCdWZmZXIuZnJvbShgJHt1c2VybmFtZX06JHtEYXRlLm5vdygpfWApLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgIG5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgIGZpcnN0X25hbWU6IHVzZXIuZmlyc3RfbmFtZSB8fCAnJyxcbiAgICAgICAgICAgIGxhc3RfbmFtZTogdXNlci5sYXN0X25hbWUgfHwgJycsXG4gICAgICAgICAgICByb2xlczogdXNlci5yb2xlcyB8fCBbJ3N1YnNjcmliZXInXSxcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczogdXNlci5jYXBhYmlsaXRpZXMgfHwge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRva2VuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB1c2VyIG5vdCBmb3VuZCBpbiBXb3JkUHJlc3MsIGNoZWNrIGlmIGl0J3MgYSBsb2NhbCB1c2VyXG4gICAgLy8gRm9yIGRlbW8gcHVycG9zZXMsIHdlJ2xsIHNpbXVsYXRlIGxvY2FsIHVzZXIgYXV0aGVudGljYXRpb25cbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3Ugd291bGQgY2hlY2sgYWdhaW5zdCB5b3VyIGxvY2FsIGRhdGFiYXNlXG4gICAgXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgY3JlYXRlIGEgbW9jayBsb2NhbCB1c2VyIGZvciBkZW1vbnN0cmF0aW9uXG4gICAgLy8gVGhpcyBhbGxvd3MgdXNlcnMgdG8gbG9naW4gZXZlbiBpZiB0aGV5J3JlIG5vdCBpbiBXb3JkUHJlc3MgeWV0XG4gICAgY29uc3QgbW9ja0xvY2FsVXNlciA9IHtcbiAgICAgIGlkOiBEYXRlLm5vdygpLFxuICAgICAgdXNlcm5hbWUsXG4gICAgICBlbWFpbDogdXNlcm5hbWUsXG4gICAgICBuYW1lOiAnTG9jYWwgVXNlcicsXG4gICAgICBmaXJzdF9uYW1lOiAnTG9jYWwnLFxuICAgICAgbGFzdF9uYW1lOiAnVXNlcicsXG4gICAgICByb2xlczogWydzdWJzY3JpYmVyJ10sXG4gICAgICBjYXBhYmlsaXRpZXM6IHt9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRva2VuID0gQnVmZmVyLmZyb20oYCR7dXNlcm5hbWV9OiR7RGF0ZS5ub3coKX1gKS50b1N0cmluZygnYmFzZTY0JylcbiAgICBcbiAgICBjb25zb2xlLmxvZygnTG9jYWwgdXNlciBhdXRoZW50aWNhdGlvbiBzdWNjZXNzZnVsOicsIG1vY2tMb2NhbFVzZXIpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB1c2VyOiBtb2NrTG9jYWxVc2VyLFxuICAgICAgdG9rZW5cbiAgICB9XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignQXV0aGVudGljYXRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiBzZXJ2aWNlIHVuYXZhaWxhYmxlJ1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIldPUkRQUkVTU19BUElfQkFTRSIsImZldGNoUG9zdHNCeUNhdGVnb3J5IiwiY2F0ZWdvcnlTbHVnIiwicGFnZSIsInBlclBhZ2UiLCJjYXRlZ29yeVJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImNhdGVnb3JpZXMiLCJqc29uIiwibGVuZ3RoIiwiY2F0ZWdvcnlJZCIsImlkIiwicmVzcG9uc2UiLCJlcnJvciIsImNvbnNvbGUiLCJmZXRjaEFsbENhdGVnb3JpZXMiLCJmZXRjaFBvc3QiLCJzbHVnIiwicG9zdHMiLCJmZXRjaFJlY2VudFBvc3RzIiwidXJsIiwiZ2V0RmVhdHVyZWRJbWFnZVVybCIsInBvc3QiLCJfZW1iZWRkZWQiLCJzb3VyY2VfdXJsIiwiZ2V0UG9zdEV4Y2VycHQiLCJtYXhMZW5ndGgiLCJjbGVhblRleHQiLCJleGNlcnB0IiwicmVuZGVyZWQiLCJyZXBsYWNlIiwidHJpbSIsInN1YnN0cmluZyIsImZvcm1hdFBvc3REYXRlIiwiZGF0ZVN0cmluZyIsImRhdGUiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwieWVhciIsIm1vbnRoIiwiZGF5IiwicHJvY2Vzc1dvcmRQcmVzc1Bvc3QiLCJ0aXRsZSIsImNvbnRlbnQiLCJwcm9jZXNzV29yZFByZXNzUG9zdHMiLCJtYXAiLCJnZXRDYXRlZ29yeU5hbWUiLCJuYW1lIiwiQ0FURUdPUllfU0xVR1MiLCJyZWdpc3RlcldvcmRQcmVzc1VzZXIiLCJ1c2VybmFtZSIsImVtYWlsIiwicGFzc3dvcmQiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImxvZyIsImF1dGgiLCJCdWZmZXIiLCJmcm9tIiwicHJvY2VzcyIsImVudiIsIldPUkRQUkVTU19BUElfVVNFUk5BTUUiLCJXT1JEUFJFU1NfQVBJX1BBU1NXT1JEIiwidG9TdHJpbmciLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwicm9sZXMiLCJzdGF0dXMiLCJ1c2VyRGF0YSIsInRva2VuIiwibm93Iiwic3VjY2VzcyIsInVzZXIiLCJjYXBhYmlsaXRpZXMiLCJlcnJvckRhdGEiLCJjb2RlIiwibG9jYWxVc2VyIiwiY3JlYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwid3Bfc3luY2VkIiwibWVzc2FnZSIsImF1dGhlbnRpY2F0ZVdvcmRQcmVzc1VzZXIiLCJlbWFpbFJlZ2V4IiwidGVzdCIsInVzZXJzIiwiZmluZCIsInUiLCJtb2NrTG9jYWxVc2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/wordpress-api.ts\n"));

/***/ })

});