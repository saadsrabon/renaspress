"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/news/[slug]/page",{

/***/ "(app-pages-browser)/./lib/wordpress-api.ts":
/*!******************************!*\
  !*** ./lib/wordpress-api.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CATEGORY_SLUGS: function() { return /* binding */ CATEGORY_SLUGS; },\n/* harmony export */   authenticateWordPressUser: function() { return /* binding */ authenticateWordPressUser; },\n/* harmony export */   fetchAllCategories: function() { return /* binding */ fetchAllCategories; },\n/* harmony export */   fetchPost: function() { return /* binding */ fetchPost; },\n/* harmony export */   fetchPostsByCategory: function() { return /* binding */ fetchPostsByCategory; },\n/* harmony export */   fetchRecentPosts: function() { return /* binding */ fetchRecentPosts; },\n/* harmony export */   formatPostDate: function() { return /* binding */ formatPostDate; },\n/* harmony export */   getCategoryName: function() { return /* binding */ getCategoryName; },\n/* harmony export */   getFeaturedImageUrl: function() { return /* binding */ getFeaturedImageUrl; },\n/* harmony export */   getPostExcerpt: function() { return /* binding */ getPostExcerpt; },\n/* harmony export */   registerWordPressUser: function() { return /* binding */ registerWordPressUser; },\n/* harmony export */   testWordPressAPI: function() { return /* binding */ testWordPressAPI; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nconst WORDPRESS_API_BASE = \"https://renaspress.com/wp-json/wp/v2\";\n// Debug function to test WordPress API connectivity\nasync function testWordPressAPI() {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/users?per_page=1\"));\n        if (response.ok) {\n            return {\n                success: true\n            };\n        } else {\n            const errorData = await response.json();\n            return {\n                success: false,\n                error: \"WordPress API error: \".concat(response.status, \" - \").concat(errorData.message || \"Unknown error\")\n            };\n        }\n    } catch (error) {\n        return {\n            success: false,\n            error: \"WordPress API connection failed: \".concat(error)\n        };\n    }\n}\nasync function fetchPostsByCategory(categorySlug) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, perPage = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    try {\n        // First, get the category ID by slug\n        const categoryResponse = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?slug=\").concat(categorySlug));\n        if (!categoryResponse.ok) {\n            throw new Error(\"Failed to fetch category: \".concat(categoryResponse.statusText));\n        }\n        const categories = await categoryResponse.json();\n        if (categories.length === 0) {\n            return [];\n        }\n        const categoryId = categories[0].id;\n        // Fetch posts by category ID\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/posts?categories=\").concat(categoryId, \"&page=\").concat(page, \"&per_page=\").concat(perPage, \"&_embed=true\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch posts: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching posts:\", error);\n        return [];\n    }\n}\nasync function fetchAllCategories() {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?per_page=100\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch categories: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching categories:\", error);\n        return [];\n    }\n}\nasync function fetchPost(slug) {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/posts?slug=\").concat(slug, \"&_embed=true\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch post: \".concat(response.statusText));\n        }\n        const posts = await response.json();\n        return posts.length > 0 ? posts[0] : null;\n    } catch (error) {\n        console.error(\"Error fetching post:\", error);\n        return null;\n    }\n}\nasync function fetchRecentPosts() {\n    let perPage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, categorySlug = arguments.length > 1 ? arguments[1] : void 0;\n    try {\n        let url = \"\".concat(WORDPRESS_API_BASE, \"/posts?per_page=\").concat(perPage, \"&orderby=date&order=desc&_embed=true\");\n        // If category is specified, filter by category\n        if (categorySlug) {\n            const categoryResponse = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?slug=\").concat(categorySlug));\n            if (categoryResponse.ok) {\n                const categories = await categoryResponse.json();\n                if (categories.length > 0) {\n                    url += \"&categories=\".concat(categories[0].id);\n                }\n            }\n        }\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch recent posts: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching recent posts:\", error);\n        return [];\n    }\n}\nfunction getFeaturedImageUrl(post) {\n    var _post__embedded_wpfeaturedmedia_, _post__embedded_wpfeaturedmedia, _post__embedded;\n    if ((_post__embedded = post._embedded) === null || _post__embedded === void 0 ? void 0 : (_post__embedded_wpfeaturedmedia = _post__embedded[\"wp:featuredmedia\"]) === null || _post__embedded_wpfeaturedmedia === void 0 ? void 0 : (_post__embedded_wpfeaturedmedia_ = _post__embedded_wpfeaturedmedia[0]) === null || _post__embedded_wpfeaturedmedia_ === void 0 ? void 0 : _post__embedded_wpfeaturedmedia_.source_url) {\n        return post._embedded[\"wp:featuredmedia\"][0].source_url;\n    }\n    return \"/api/placeholder/800/500\";\n}\nfunction getPostExcerpt(post) {\n    let maxLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 150;\n    // Remove HTML tags and get clean text\n    const cleanText = post.excerpt.rendered.replace(/<[^>]*>/g, \"\").replace(/&[^;]+;/g, \" \").trim();\n    if (cleanText.length <= maxLength) {\n        return cleanText;\n    }\n    return cleanText.substring(0, maxLength).replace(/\\s+\\S*$/, \"\") + \"...\";\n}\nfunction formatPostDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString(\"en-US\", {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    });\n}\nfunction getCategoryName(post) {\n    var _post__embedded_wpterm, _post__embedded;\n    if ((_post__embedded = post._embedded) === null || _post__embedded === void 0 ? void 0 : (_post__embedded_wpterm = _post__embedded[\"wp:term\"]) === null || _post__embedded_wpterm === void 0 ? void 0 : _post__embedded_wpterm[0]) {\n        var _categories_;\n        const categories = post._embedded[\"wp:term\"][0];\n        return ((_categories_ = categories[0]) === null || _categories_ === void 0 ? void 0 : _categories_.name) || \"Uncategorized\";\n    }\n    return \"Uncategorized\";\n}\n// Category mapping for the specific categories mentioned\nconst CATEGORY_SLUGS = {\n    \"daily-news\": \"daily-news\",\n    \"charity\": \"charity\",\n    \"sports\": \"sports\",\n    \"woman\": \"woman\",\n    \"political-news\": \"political-news\"\n};\nasync function registerWordPressUser(username, email, password, firstName, lastName) {\n    try {\n        console.log(\"Attempting to register user:\", {\n            username,\n            email,\n            firstName,\n            lastName\n        });\n        // Try to register user directly - WordPress will return an error if user exists\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/users\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                username,\n                email,\n                password,\n                first_name: firstName,\n                last_name: lastName,\n                roles: [\n                    \"subscriber\"\n                ]\n            })\n        });\n        console.log(\"WordPress registration response status:\", response.status);\n        if (response.ok) {\n            const userData = await response.json();\n            const token = Buffer.from(\"\".concat(email, \":\").concat(Date.now())).toString(\"base64\");\n            return {\n                success: true,\n                user: {\n                    id: userData.id,\n                    username: userData.username,\n                    email: userData.email,\n                    name: userData.name,\n                    first_name: userData.first_name,\n                    last_name: userData.last_name,\n                    roles: userData.roles || [\n                        \"subscriber\"\n                    ],\n                    capabilities: userData.capabilities || {}\n                },\n                token\n            };\n        } else {\n            const errorData = await response.json();\n            console.log(\"WordPress registration error response:\", errorData);\n            // Handle specific WordPress error codes\n            if (response.status === 400) {\n                if (errorData.code === \"existing_user_email\") {\n                    return {\n                        success: false,\n                        error: \"An account with this email already exists\"\n                    };\n                } else if (errorData.code === \"existing_user_login\") {\n                    return {\n                        success: false,\n                        error: \"An account with this username already exists\"\n                    };\n                } else if (errorData.message) {\n                    return {\n                        success: false,\n                        error: errorData.message\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: errorData.message || \"Registration failed (\".concat(response.status, \")\")\n            };\n        }\n    } catch (error) {\n        console.error(\"WordPress registration error:\", error);\n        return {\n            success: false,\n            error: \"Registration service unavailable. Please try again later.\"\n        };\n    }\n}\nasync function authenticateWordPressUser(username, password) {\n    try {\n        // WordPress doesn't have a direct login endpoint via REST API\n        // We need to use application passwords or implement custom authentication\n        // For now, we'll use a workaround by checking user existence and creating a session\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/users?search=\").concat(username));\n        if (!response.ok) {\n            return {\n                success: false,\n                error: \"Authentication service unavailable\"\n            };\n        }\n        const users = await response.json();\n        const user = users.find((u)=>u.email === username || u.username === username);\n        if (!user) {\n            return {\n                success: false,\n                error: \"Invalid credentials\"\n            };\n        }\n        // In a real implementation, you would verify the password\n        // For now, we'll create a token and return user data\n        const token = Buffer.from(\"\".concat(username, \":\").concat(Date.now())).toString(\"base64\");\n        return {\n            success: true,\n            user: {\n                id: user.id,\n                username: user.username,\n                email: user.email,\n                name: user.name,\n                first_name: user.first_name || \"\",\n                last_name: user.last_name || \"\",\n                roles: user.roles || [\n                    \"subscriber\"\n                ],\n                capabilities: user.capabilities || {}\n            },\n            token\n        };\n    } catch (error) {\n        console.error(\"WordPress authentication error:\", error);\n        return {\n            success: false,\n            error: \"Authentication service unavailable\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi93b3JkcHJlc3MtYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Q0EsTUFBTUEscUJBQXFCO0FBRTNCLG9EQUFvRDtBQUM3QyxlQUFlQztJQUNwQixJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQXNCLE9BQW5CSCxvQkFBbUI7UUFDbkQsSUFBSUUsU0FBU0UsRUFBRSxFQUFFO1lBQ2YsT0FBTztnQkFBRUMsU0FBUztZQUFLO1FBQ3pCLE9BQU87WUFDTCxNQUFNQyxZQUFZLE1BQU1KLFNBQVNLLElBQUk7WUFDckMsT0FBTztnQkFDTEYsU0FBUztnQkFDVEcsT0FBTyx3QkFBNkNGLE9BQXJCSixTQUFTTyxNQUFNLEVBQUMsT0FBMEMsT0FBckNILFVBQVVJLE9BQU8sSUFBSTtZQUMzRTtRQUNGO0lBQ0YsRUFBRSxPQUFPRixPQUFPO1FBQ2QsT0FBTztZQUNMSCxTQUFTO1lBQ1RHLE9BQU8sb0NBQTBDLE9BQU5BO1FBQzdDO0lBQ0Y7QUFDRjtBQUVPLGVBQWVHLHFCQUNwQkMsWUFBb0I7UUFDcEJDLE9BQUFBLGlFQUFlLEdBQ2ZDLFVBQUFBLGlFQUFrQjtJQUVsQixJQUFJO1FBQ0YscUNBQXFDO1FBQ3JDLE1BQU1DLG1CQUFtQixNQUFNWixNQUM3QixHQUF5Q1MsT0FBdENaLG9CQUFtQixxQkFBZ0MsT0FBYlk7UUFHM0MsSUFBSSxDQUFDRyxpQkFBaUJYLEVBQUUsRUFBRTtZQUN4QixNQUFNLElBQUlZLE1BQU0sNkJBQXlELE9BQTVCRCxpQkFBaUJFLFVBQVU7UUFDMUU7UUFFQSxNQUFNQyxhQUFhLE1BQU1ILGlCQUFpQlIsSUFBSTtRQUU5QyxJQUFJVyxXQUFXQyxNQUFNLEtBQUssR0FBRztZQUMzQixPQUFPLEVBQUU7UUFDWDtRQUVBLE1BQU1DLGFBQWFGLFVBQVUsQ0FBQyxFQUFFLENBQUNHLEVBQUU7UUFFbkMsNkJBQTZCO1FBQzdCLE1BQU1uQixXQUFXLE1BQU1DLE1BQ3JCLEdB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QUFDO1FBRWhFLE9BQU87WUFDTG5FLFNBQVM7WUFDVG9FLE1BQU07Z0JBQ0pwRCxJQUFJb0QsS0FBS3BELEVBQUU7Z0JBQ1hnQyxVQUFVb0IsS0FBS3BCLFFBQVE7Z0JBQ3ZCQyxPQUFPbUIsS0FBS25CLEtBQUs7Z0JBQ2pCSixNQUFNdUIsS0FBS3ZCLElBQUk7Z0JBQ2ZjLFlBQVlTLEtBQUtULFVBQVUsSUFBSTtnQkFDL0JDLFdBQVdRLEtBQUtSLFNBQVMsSUFBSTtnQkFDN0JDLE9BQU9PLEtBQUtQLEtBQUssSUFBSTtvQkFBQztpQkFBYTtnQkFDbkNRLGNBQWNELEtBQUtDLFlBQVksSUFBSSxDQUFDO1lBQ3RDO1lBQ0FOO1FBQ0Y7SUFDRixFQUFFLE9BQU81RCxPQUFPO1FBQ2RjLFFBQVFkLEtBQUssQ0FBQyxtQ0FBbUNBO1FBQ2pELE9BQU87WUFDTEgsU0FBUztZQUNURyxPQUFPO1FBQ1Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi93b3JkcHJlc3MtYXBpLnRzP2VlNGQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBXb3JkUHJlc3NQb3N0IHtcclxuICBpZDogbnVtYmVyXHJcbiAgdGl0bGU6IHtcclxuICAgIHJlbmRlcmVkOiBzdHJpbmdcclxuICB9XHJcbiAgY29udGVudDoge1xyXG4gICAgcmVuZGVyZWQ6IHN0cmluZ1xyXG4gIH1cclxuICBleGNlcnB0OiB7XHJcbiAgICByZW5kZXJlZDogc3RyaW5nXHJcbiAgfVxyXG4gIGRhdGU6IHN0cmluZ1xyXG4gIG1vZGlmaWVkOiBzdHJpbmdcclxuICBzbHVnOiBzdHJpbmdcclxuICBsaW5rOiBzdHJpbmdcclxuICBmZWF0dXJlZF9tZWRpYTogbnVtYmVyXHJcbiAgY2F0ZWdvcmllczogbnVtYmVyW11cclxuICB0YWdzOiBudW1iZXJbXVxyXG4gIF9lbWJlZGRlZD86IHtcclxuICAgICd3cDpmZWF0dXJlZG1lZGlhJz86IEFycmF5PHtcclxuICAgICAgc291cmNlX3VybDogc3RyaW5nXHJcbiAgICAgIGFsdF90ZXh0OiBzdHJpbmdcclxuICAgIH0+XHJcbiAgICAnd3A6dGVybSc/OiBBcnJheTxBcnJheTx7XHJcbiAgICAgIGlkOiBudW1iZXJcclxuICAgICAgbmFtZTogc3RyaW5nXHJcbiAgICAgIHNsdWc6IHN0cmluZ1xyXG4gICAgICB0YXhvbm9teTogc3RyaW5nXHJcbiAgICB9Pj5cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV29yZFByZXNzQ2F0ZWdvcnkge1xyXG4gIGlkOiBudW1iZXJcclxuICBuYW1lOiBzdHJpbmdcclxuICBzbHVnOiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgY291bnQ6IG51bWJlclxyXG59XHJcblxyXG5jb25zdCBXT1JEUFJFU1NfQVBJX0JBU0UgPSAnaHR0cHM6Ly9yZW5hc3ByZXNzLmNvbS93cC1qc29uL3dwL3YyJ1xyXG5cclxuLy8gRGVidWcgZnVuY3Rpb24gdG8gdGVzdCBXb3JkUHJlc3MgQVBJIGNvbm5lY3Rpdml0eVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdFdvcmRQcmVzc0FQSSgpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke1dPUkRQUkVTU19BUElfQkFTRX0vdXNlcnM/cGVyX3BhZ2U9MWApXHJcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICAgIGVycm9yOiBgV29yZFByZXNzIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9IC0gJHtlcnJvckRhdGEubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4geyBcclxuICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICBlcnJvcjogYFdvcmRQcmVzcyBBUEkgY29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YCBcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFBvc3RzQnlDYXRlZ29yeShcclxuICBjYXRlZ29yeVNsdWc6IHN0cmluZyxcclxuICBwYWdlOiBudW1iZXIgPSAxLFxyXG4gIHBlclBhZ2U6IG51bWJlciA9IDEwXHJcbik6IFByb21pc2U8V29yZFByZXNzUG9zdFtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEZpcnN0LCBnZXQgdGhlIGNhdGVnb3J5IElEIGJ5IHNsdWdcclxuICAgIGNvbnN0IGNhdGVnb3J5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgYCR7V09SRFBSRVNTX0FQSV9CQVNFfS9jYXRlZ29yaWVzP3NsdWc9JHtjYXRlZ29yeVNsdWd9YFxyXG4gICAgKVxyXG4gICAgXHJcbiAgICBpZiAoIWNhdGVnb3J5UmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggY2F0ZWdvcnk6ICR7Y2F0ZWdvcnlSZXNwb25zZS5zdGF0dXNUZXh0fWApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBhd2FpdCBjYXRlZ29yeVJlc3BvbnNlLmpzb24oKVxyXG4gICAgXHJcbiAgICBpZiAoY2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGNhdGVnb3J5SWQgPSBjYXRlZ29yaWVzWzBdLmlkXHJcbiAgICBcclxuICAgIC8vIEZldGNoIHBvc3RzIGJ5IGNhdGVnb3J5IElEXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICBgJHtXT1JEUFJFU1NfQVBJX0JBU0V9L3Bvc3RzP2NhdGVnb3JpZXM9JHtjYXRlZ29yeUlkfSZwYWdlPSR7cGFnZX0mcGVyX3BhZ2U9JHtwZXJQYWdlfSZfZW1iZWQ9dHJ1ZWBcclxuICAgIClcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwb3N0czogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9zdHM6JywgZXJyb3IpXHJcbiAgICByZXR1cm4gW11cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFsbENhdGVnb3JpZXMoKTogUHJvbWlzZTxXb3JkUHJlc3NDYXRlZ29yeVtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7V09SRFBSRVNTX0FQSV9CQVNFfS9jYXRlZ29yaWVzP3Blcl9wYWdlPTEwMGApXHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggY2F0ZWdvcmllczogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcmllczonLCBlcnJvcilcclxuICAgIHJldHVybiBbXVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUG9zdChzbHVnOiBzdHJpbmcpOiBQcm9taXNlPFdvcmRQcmVzc1Bvc3QgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgIGAke1dPUkRQUkVTU19BUElfQkFTRX0vcG9zdHM/c2x1Zz0ke3NsdWd9Jl9lbWJlZD10cnVlYFxyXG4gICAgKVxyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHBvc3Q6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBwb3N0cyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgcmV0dXJuIHBvc3RzLmxlbmd0aCA+IDAgPyBwb3N0c1swXSA6IG51bGxcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9zdDonLCBlcnJvcilcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWNlbnRQb3N0cyhcclxuICBwZXJQYWdlOiBudW1iZXIgPSAxMCxcclxuICBjYXRlZ29yeVNsdWc/OiBzdHJpbmdcclxuKTogUHJvbWlzZTxXb3JkUHJlc3NQb3N0W10+IHtcclxuICB0cnkge1xyXG4gICAgbGV0IHVybCA9IGAke1dPUkRQUkVTU19BUElfQkFTRX0vcG9zdHM/cGVyX3BhZ2U9JHtwZXJQYWdlfSZvcmRlcmJ5PWRhdGUmb3JkZXI9ZGVzYyZfZW1iZWQ9dHJ1ZWBcclxuICAgIFxyXG4gICAgLy8gSWYgY2F0ZWdvcnkgaXMgc3BlY2lmaWVkLCBmaWx0ZXIgYnkgY2F0ZWdvcnlcclxuICAgIGlmIChjYXRlZ29yeVNsdWcpIHtcclxuICAgICAgY29uc3QgY2F0ZWdvcnlSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgIGAke1dPUkRQUkVTU19BUElfQkFTRX0vY2F0ZWdvcmllcz9zbHVnPSR7Y2F0ZWdvcnlTbHVnfWBcclxuICAgICAgKVxyXG4gICAgICBcclxuICAgICAgaWYgKGNhdGVnb3J5UmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gYXdhaXQgY2F0ZWdvcnlSZXNwb25zZS5qc29uKClcclxuICAgICAgICBpZiAoY2F0ZWdvcmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB1cmwgKz0gYCZjYXRlZ29yaWVzPSR7Y2F0ZWdvcmllc1swXS5pZH1gXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKVxyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHJlY2VudCBwb3N0czogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50IHBvc3RzOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIFtdXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZWRJbWFnZVVybChwb3N0OiBXb3JkUHJlc3NQb3N0KTogc3RyaW5nIHtcclxuICBpZiAocG9zdC5fZW1iZWRkZWQ/Llsnd3A6ZmVhdHVyZWRtZWRpYSddPy5bMF0/LnNvdXJjZV91cmwpIHtcclxuICAgIHJldHVybiBwb3N0Ll9lbWJlZGRlZFsnd3A6ZmVhdHVyZWRtZWRpYSddWzBdLnNvdXJjZV91cmxcclxuICB9XHJcbiAgcmV0dXJuICcvYXBpL3BsYWNlaG9sZGVyLzgwMC81MDAnXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3N0RXhjZXJwdChwb3N0OiBXb3JkUHJlc3NQb3N0LCBtYXhMZW5ndGg6IG51bWJlciA9IDE1MCk6IHN0cmluZyB7XHJcbiAgLy8gUmVtb3ZlIEhUTUwgdGFncyBhbmQgZ2V0IGNsZWFuIHRleHRcclxuICBjb25zdCBjbGVhblRleHQgPSBwb3N0LmV4Y2VycHQucmVuZGVyZWRcclxuICAgIC5yZXBsYWNlKC88W14+XSo+L2csICcnKVxyXG4gICAgLnJlcGxhY2UoLyZbXjtdKzsvZywgJyAnKVxyXG4gICAgLnRyaW0oKVxyXG4gIFxyXG4gIGlmIChjbGVhblRleHQubGVuZ3RoIDw9IG1heExlbmd0aCkge1xyXG4gICAgcmV0dXJuIGNsZWFuVGV4dFxyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW5UZXh0LnN1YnN0cmluZygwLCBtYXhMZW5ndGgpLnJlcGxhY2UoL1xccytcXFMqJC8sICcnKSArICcuLi4nXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRQb3N0RGF0ZShkYXRlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKVxyXG4gIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7XHJcbiAgICB5ZWFyOiAnbnVtZXJpYycsXHJcbiAgICBtb250aDogJ2xvbmcnLFxyXG4gICAgZGF5OiAnbnVtZXJpYydcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2F0ZWdvcnlOYW1lKHBvc3Q6IFdvcmRQcmVzc1Bvc3QpOiBzdHJpbmcge1xyXG4gIGlmIChwb3N0Ll9lbWJlZGRlZD8uWyd3cDp0ZXJtJ10/LlswXSkge1xyXG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IHBvc3QuX2VtYmVkZGVkWyd3cDp0ZXJtJ11bMF1cclxuICAgIHJldHVybiBjYXRlZ29yaWVzWzBdPy5uYW1lIHx8ICdVbmNhdGVnb3JpemVkJ1xyXG4gIH1cclxuICByZXR1cm4gJ1VuY2F0ZWdvcml6ZWQnXHJcbn1cclxuXHJcbi8vIENhdGVnb3J5IG1hcHBpbmcgZm9yIHRoZSBzcGVjaWZpYyBjYXRlZ29yaWVzIG1lbnRpb25lZFxyXG5leHBvcnQgY29uc3QgQ0FURUdPUllfU0xVR1MgPSB7XHJcbiAgJ2RhaWx5LW5ld3MnOiAnZGFpbHktbmV3cycsXHJcbiAgJ2NoYXJpdHknOiAnY2hhcml0eScsIFxyXG4gICdzcG9ydHMnOiAnc3BvcnRzJyxcclxuICAnd29tYW4nOiAnd29tYW4nLFxyXG4gICdwb2xpdGljYWwtbmV3cyc6ICdwb2xpdGljYWwtbmV3cydcclxufSBhcyBjb25zdFxyXG5cclxuZXhwb3J0IHR5cGUgQ2F0ZWdvcnlTbHVnID0ga2V5b2YgdHlwZW9mIENBVEVHT1JZX1NMVUdTXHJcblxyXG4vLyBXb3JkUHJlc3MgQXV0aGVudGljYXRpb24gRnVuY3Rpb25zXHJcbmV4cG9ydCBpbnRlcmZhY2UgV29yZFByZXNzVXNlciB7XHJcbiAgaWQ6IG51bWJlclxyXG4gIHVzZXJuYW1lOiBzdHJpbmdcclxuICBlbWFpbDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZmlyc3RfbmFtZTogc3RyaW5nXHJcbiAgbGFzdF9uYW1lOiBzdHJpbmdcclxuICByb2xlczogc3RyaW5nW11cclxuICBjYXBhYmlsaXRpZXM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFJlc3BvbnNlIHtcclxuICBzdWNjZXNzOiBib29sZWFuXHJcbiAgdXNlcj86IFdvcmRQcmVzc1VzZXJcclxuICB0b2tlbj86IHN0cmluZ1xyXG4gIGVycm9yPzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWdpc3RlcldvcmRQcmVzc1VzZXIoXHJcbiAgdXNlcm5hbWU6IHN0cmluZyxcclxuICBlbWFpbDogc3RyaW5nLFxyXG4gIHBhc3N3b3JkOiBzdHJpbmcsXHJcbiAgZmlyc3ROYW1lOiBzdHJpbmcsXHJcbiAgbGFzdE5hbWU6IHN0cmluZ1xyXG4pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byByZWdpc3RlciB1c2VyOicsIHsgdXNlcm5hbWUsIGVtYWlsLCBmaXJzdE5hbWUsIGxhc3ROYW1lIH0pXHJcbiAgICBcclxuICAgIC8vIFRyeSB0byByZWdpc3RlciB1c2VyIGRpcmVjdGx5IC0gV29yZFByZXNzIHdpbGwgcmV0dXJuIGFuIGVycm9yIGlmIHVzZXIgZXhpc3RzXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke1dPUkRQUkVTU19BUElfQkFTRX0vdXNlcnNgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAvLyBOb3RlOiBXb3JkUHJlc3MgUkVTVCBBUEkgbWlnaHQgcmVxdWlyZSBhdXRoZW50aWNhdGlvbiBmb3IgdXNlciBjcmVhdGlvblxyXG4gICAgICAgIC8vIElmIHRoaXMgZmFpbHMsIHdlIG1heSBuZWVkIHRvIHVzZSBhIGRpZmZlcmVudCBhcHByb2FjaFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgcGFzc3dvcmQsXHJcbiAgICAgICAgZmlyc3RfbmFtZTogZmlyc3ROYW1lLFxyXG4gICAgICAgIGxhc3RfbmFtZTogbGFzdE5hbWUsXHJcbiAgICAgICAgcm9sZXM6IFsnc3Vic2NyaWJlciddXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnV29yZFByZXNzIHJlZ2lzdHJhdGlvbiByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKVxyXG5cclxuICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICBjb25zdCB0b2tlbiA9IEJ1ZmZlci5mcm9tKGAke2VtYWlsfToke0RhdGUubm93KCl9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgdXNlcjoge1xyXG4gICAgICAgICAgaWQ6IHVzZXJEYXRhLmlkLFxyXG4gICAgICAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lLFxyXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxyXG4gICAgICAgICAgbmFtZTogdXNlckRhdGEubmFtZSxcclxuICAgICAgICAgIGZpcnN0X25hbWU6IHVzZXJEYXRhLmZpcnN0X25hbWUsXHJcbiAgICAgICAgICBsYXN0X25hbWU6IHVzZXJEYXRhLmxhc3RfbmFtZSxcclxuICAgICAgICAgIHJvbGVzOiB1c2VyRGF0YS5yb2xlcyB8fCBbJ3N1YnNjcmliZXInXSxcclxuICAgICAgICAgIGNhcGFiaWxpdGllczogdXNlckRhdGEuY2FwYWJpbGl0aWVzIHx8IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b2tlblxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgY29uc29sZS5sb2coJ1dvcmRQcmVzcyByZWdpc3RyYXRpb24gZXJyb3IgcmVzcG9uc2U6JywgZXJyb3JEYXRhKVxyXG4gICAgICBcclxuICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIFdvcmRQcmVzcyBlcnJvciBjb2Rlc1xyXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDApIHtcclxuICAgICAgICBpZiAoZXJyb3JEYXRhLmNvZGUgPT09ICdleGlzdGluZ191c2VyX2VtYWlsJykge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiAnQW4gYWNjb3VudCB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckRhdGEuY29kZSA9PT0gJ2V4aXN0aW5nX3VzZXJfbG9naW4nKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6ICdBbiBhY2NvdW50IHdpdGggdGhpcyB1c2VybmFtZSBhbHJlYWR5IGV4aXN0cydcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGVycm9yRGF0YS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5tZXNzYWdlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiBlcnJvckRhdGEubWVzc2FnZSB8fCBgUmVnaXN0cmF0aW9uIGZhaWxlZCAoJHtyZXNwb25zZS5zdGF0dXN9KWBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdXb3JkUHJlc3MgcmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiAnUmVnaXN0cmF0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJ1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZVdvcmRQcmVzc1VzZXIoXHJcbiAgdXNlcm5hbWU6IHN0cmluZyxcclxuICBwYXNzd29yZDogc3RyaW5nXHJcbik6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFdvcmRQcmVzcyBkb2Vzbid0IGhhdmUgYSBkaXJlY3QgbG9naW4gZW5kcG9pbnQgdmlhIFJFU1QgQVBJXHJcbiAgICAvLyBXZSBuZWVkIHRvIHVzZSBhcHBsaWNhdGlvbiBwYXNzd29yZHMgb3IgaW1wbGVtZW50IGN1c3RvbSBhdXRoZW50aWNhdGlvblxyXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgdXNlIGEgd29ya2Fyb3VuZCBieSBjaGVja2luZyB1c2VyIGV4aXN0ZW5jZSBhbmQgY3JlYXRpbmcgYSBzZXNzaW9uXHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgIGAke1dPUkRQUkVTU19BUElfQkFTRX0vdXNlcnM/c2VhcmNoPSR7dXNlcm5hbWV9YFxyXG4gICAgKVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUnXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgY29uc3QgdXNlciA9IHVzZXJzLmZpbmQoKHU6IGFueSkgPT4gdS5lbWFpbCA9PT0gdXNlcm5hbWUgfHwgdS51c2VybmFtZSA9PT0gdXNlcm5hbWUpXHJcblxyXG4gICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6ICdJbnZhbGlkIGNyZWRlbnRpYWxzJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgdmVyaWZ5IHRoZSBwYXNzd29yZFxyXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgY3JlYXRlIGEgdG9rZW4gYW5kIHJldHVybiB1c2VyIGRhdGFcclxuICAgIGNvbnN0IHRva2VuID0gQnVmZmVyLmZyb20oYCR7dXNlcm5hbWV9OiR7RGF0ZS5ub3coKX1gKS50b1N0cmluZygnYmFzZTY0JylcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgdXNlcjoge1xyXG4gICAgICAgIGlkOiB1c2VyLmlkLFxyXG4gICAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxyXG4gICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxyXG4gICAgICAgIG5hbWU6IHVzZXIubmFtZSxcclxuICAgICAgICBmaXJzdF9uYW1lOiB1c2VyLmZpcnN0X25hbWUgfHwgJycsXHJcbiAgICAgICAgbGFzdF9uYW1lOiB1c2VyLmxhc3RfbmFtZSB8fCAnJyxcclxuICAgICAgICByb2xlczogdXNlci5yb2xlcyB8fCBbJ3N1YnNjcmliZXInXSxcclxuICAgICAgICBjYXBhYmlsaXRpZXM6IHVzZXIuY2FwYWJpbGl0aWVzIHx8IHt9XHJcbiAgICAgIH0sXHJcbiAgICAgIHRva2VuXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1dvcmRQcmVzcyBhdXRoZW50aWNhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUnXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJXT1JEUFJFU1NfQVBJX0JBU0UiLCJ0ZXN0V29yZFByZXNzQVBJIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3VjY2VzcyIsImVycm9yRGF0YSIsImpzb24iLCJlcnJvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJmZXRjaFBvc3RzQnlDYXRlZ29yeSIsImNhdGVnb3J5U2x1ZyIsInBhZ2UiLCJwZXJQYWdlIiwiY2F0ZWdvcnlSZXNwb25zZSIsIkVycm9yIiwic3RhdHVzVGV4dCIsImNhdGVnb3JpZXMiLCJsZW5ndGgiLCJjYXRlZ29yeUlkIiwiaWQiLCJjb25zb2xlIiwiZmV0Y2hBbGxDYXRlZ29yaWVzIiwiZmV0Y2hQb3N0Iiwic2x1ZyIsInBvc3RzIiwiZmV0Y2hSZWNlbnRQb3N0cyIsInVybCIsImdldEZlYXR1cmVkSW1hZ2VVcmwiLCJwb3N0IiwiX2VtYmVkZGVkIiwic291cmNlX3VybCIsImdldFBvc3RFeGNlcnB0IiwibWF4TGVuZ3RoIiwiY2xlYW5UZXh0IiwiZXhjZXJwdCIsInJlbmRlcmVkIiwicmVwbGFjZSIsInRyaW0iLCJzdWJzdHJpbmciLCJmb3JtYXRQb3N0RGF0ZSIsImRhdGVTdHJpbmciLCJkYXRlIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInllYXIiLCJtb250aCIsImRheSIsImdldENhdGVnb3J5TmFtZSIsIm5hbWUiLCJDQVRFR09SWV9TTFVHUyIsInJlZ2lzdGVyV29yZFByZXNzVXNlciIsInVzZXJuYW1lIiwiZW1haWwiLCJwYXNzd29yZCIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwibG9nIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsInJvbGVzIiwidXNlckRhdGEiLCJ0b2tlbiIsIkJ1ZmZlciIsImZyb20iLCJub3ciLCJ0b1N0cmluZyIsInVzZXIiLCJjYXBhYmlsaXRpZXMiLCJjb2RlIiwiYXV0aGVudGljYXRlV29yZFByZXNzVXNlciIsInVzZXJzIiwiZmluZCIsInUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/wordpress-api.ts\n"));

/***/ })

});