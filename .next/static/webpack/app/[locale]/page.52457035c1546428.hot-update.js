"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/page",{

/***/ "(app-pages-browser)/./lib/wordpress-api.ts":
/*!******************************!*\
  !*** ./lib/wordpress-api.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CATEGORY_SLUGS: function() { return /* binding */ CATEGORY_SLUGS; },\n/* harmony export */   WORDPRESS_API_BASE: function() { return /* binding */ WORDPRESS_API_BASE; },\n/* harmony export */   authenticateWordPressUser: function() { return /* binding */ authenticateWordPressUser; },\n/* harmony export */   fetchAllCategories: function() { return /* binding */ fetchAllCategories; },\n/* harmony export */   fetchPost: function() { return /* binding */ fetchPost; },\n/* harmony export */   fetchPostsByCategory: function() { return /* binding */ fetchPostsByCategory; },\n/* harmony export */   fetchRecentPosts: function() { return /* binding */ fetchRecentPosts; },\n/* harmony export */   formatPostDate: function() { return /* binding */ formatPostDate; },\n/* harmony export */   getCategoryName: function() { return /* binding */ getCategoryName; },\n/* harmony export */   getFeaturedImageUrl: function() { return /* binding */ getFeaturedImageUrl; },\n/* harmony export */   getPostExcerpt: function() { return /* binding */ getPostExcerpt; },\n/* harmony export */   processWordPressPost: function() { return /* binding */ processWordPressPost; },\n/* harmony export */   processWordPressPosts: function() { return /* binding */ processWordPressPosts; },\n/* harmony export */   registerWordPressUser: function() { return /* binding */ registerWordPressUser; },\n/* harmony export */   testWordPressAPI: function() { return /* binding */ testWordPressAPI; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nconst WORDPRESS_API_BASE = \"https://renaspress.com/wp-json/wp/v2\";\n// Debug function to test WordPress API connectivity\nasync function testWordPressAPI() {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/users?per_page=1\"));\n        if (response.ok) {\n            return {\n                success: true\n            };\n        } else {\n            const errorData = await response.json();\n            return {\n                success: false,\n                error: \"WordPress API error: \".concat(response.status, \" - \").concat(errorData.message || \"Unknown error\")\n            };\n        }\n    } catch (error) {\n        return {\n            success: false,\n            error: \"WordPress API connection failed: \".concat(error)\n        };\n    }\n}\nasync function fetchPostsByCategory(categorySlug) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, perPage = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    try {\n        // First, get the category ID by slug\n        const categoryResponse = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?slug=\").concat(categorySlug));\n        if (!categoryResponse.ok) {\n            throw new Error(\"Failed to fetch category: \".concat(categoryResponse.statusText));\n        }\n        const categories = await categoryResponse.json();\n        if (categories.length === 0) {\n            return [];\n        }\n        const categoryId = categories[0].id;\n        // Fetch posts by category ID\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/posts?categories=\").concat(categoryId, \"&page=\").concat(page, \"&per_page=\").concat(perPage, \"&_embed=true\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch posts: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching posts:\", error);\n        return [];\n    }\n}\nasync function fetchAllCategories() {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?per_page=100\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch categories: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching categories:\", error);\n        return [];\n    }\n}\nasync function fetchPost(slug) {\n    try {\n        const response = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/posts?slug=\").concat(slug, \"&_embed=true\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch post: \".concat(response.statusText));\n        }\n        const posts = await response.json();\n        return posts.length > 0 ? posts[0] : null;\n    } catch (error) {\n        console.error(\"Error fetching post:\", error);\n        return null;\n    }\n}\nasync function fetchRecentPosts() {\n    let perPage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, categorySlug = arguments.length > 1 ? arguments[1] : void 0;\n    try {\n        let url = \"\".concat(WORDPRESS_API_BASE, \"/posts?per_page=\").concat(perPage, \"&orderby=date&order=desc&_embed=true\");\n        // If category is specified, filter by category\n        if (categorySlug) {\n            const categoryResponse = await fetch(\"\".concat(WORDPRESS_API_BASE, \"/categories?slug=\").concat(categorySlug));\n            if (categoryResponse.ok) {\n                const categories = await categoryResponse.json();\n                if (categories.length > 0) {\n                    url += \"&categories=\".concat(categories[0].id);\n                }\n            }\n        }\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch recent posts: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching recent posts:\", error);\n        return [];\n    }\n}\nfunction getFeaturedImageUrl(post) {\n    var _post__embedded_wpfeaturedmedia_, _post__embedded_wpfeaturedmedia, _post__embedded;\n    if ((_post__embedded = post._embedded) === null || _post__embedded === void 0 ? void 0 : (_post__embedded_wpfeaturedmedia = _post__embedded[\"wp:featuredmedia\"]) === null || _post__embedded_wpfeaturedmedia === void 0 ? void 0 : (_post__embedded_wpfeaturedmedia_ = _post__embedded_wpfeaturedmedia[0]) === null || _post__embedded_wpfeaturedmedia_ === void 0 ? void 0 : _post__embedded_wpfeaturedmedia_.source_url) {\n        return post._embedded[\"wp:featuredmedia\"][0].source_url;\n    }\n    return \"/api/placeholder/800/500\";\n}\nfunction getPostExcerpt(post) {\n    let maxLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 150;\n    // Remove HTML tags and get clean text\n    const cleanText = post.excerpt.rendered.replace(/<[^>]*>/g, \"\").replace(/&[^;]+;/g, \" \").trim();\n    if (cleanText.length <= maxLength) {\n        return cleanText;\n    }\n    return cleanText.substring(0, maxLength).replace(/\\s+\\S*$/, \"\") + \"...\";\n}\nfunction formatPostDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString(\"en-US\", {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    });\n}\n// Utility function to process WordPress API responses\nfunction processWordPressPost(post) {\n    return {\n        ...post,\n        title: typeof post.title === \"object\" ? post.title.rendered : post.title,\n        content: typeof post.content === \"object\" ? post.content.rendered : post.content,\n        excerpt: typeof post.excerpt === \"object\" ? post.excerpt.rendered : post.excerpt\n    };\n}\nfunction processWordPressPosts(posts) {\n    return posts.map(processWordPressPost);\n}\nfunction getCategoryName(post) {\n    var _post__embedded_wpterm, _post__embedded;\n    if ((_post__embedded = post._embedded) === null || _post__embedded === void 0 ? void 0 : (_post__embedded_wpterm = _post__embedded[\"wp:term\"]) === null || _post__embedded_wpterm === void 0 ? void 0 : _post__embedded_wpterm[0]) {\n        var _categories_;\n        const categories = post._embedded[\"wp:term\"][0];\n        return ((_categories_ = categories[0]) === null || _categories_ === void 0 ? void 0 : _categories_.name) || \"Uncategorized\";\n    }\n    return \"Uncategorized\";\n}\n// Category mapping for the specific categories mentioned\nconst CATEGORY_SLUGS = {\n    \"daily-news\": \"daily-news\",\n    \"charity\": \"charity\",\n    \"sports\": \"sports\",\n    \"woman\": \"woman\",\n    \"political-news\": \"political-news\"\n};\nasync function registerWordPressUser(username, email, password, firstName, lastName) {\n    try {\n        console.log(\"Attempting to register user with WordPress API:\", {\n            username,\n            email,\n            firstName,\n            lastName\n        });\n        // First, try to create user in WordPress\n        const auth = Buffer.from(\"\".concat(process.env.WORDPRESS_API_USERNAME, \":\").concat(process.env.WORDPRESS_API_PASSWORD)).toString(\"base64\");\n        const response = await fetch(\"\".concat(process.env.WORDPRESS_API_BASE, \"/users\"), {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Basic \".concat(auth),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                username,\n                email,\n                password,\n                first_name: firstName,\n                last_name: lastName,\n                roles: [\n                    \"subscriber\"\n                ]\n            })\n        });\n        console.log(\"WordPress registration response status:\", response.status);\n        if (response.ok) {\n            const userData = await response.json();\n            const token = Buffer.from(\"\".concat(email, \":\").concat(Date.now())).toString(\"base64\");\n            return {\n                success: true,\n                user: {\n                    id: userData.id,\n                    username: userData.username,\n                    email: userData.email,\n                    name: userData.name,\n                    first_name: userData.first_name,\n                    last_name: userData.last_name,\n                    roles: userData.roles || [\n                        \"subscriber\"\n                    ],\n                    capabilities: userData.capabilities || {}\n                },\n                token\n            };\n        } else {\n            const errorData = await response.json();\n            console.log(\"WordPress registration error response:\", errorData);\n            // If user creation fails due to permissions, create a local user\n            if (response.status === 401 && errorData.code === \"rest_cannot_create_user\") {\n                console.log(\"WordPress user creation not allowed, creating local user instead\");\n                // Create local user that can be synced with WordPress later\n                const localUser = {\n                    id: Date.now(),\n                    username,\n                    email,\n                    name: \"\".concat(firstName, \" \").concat(lastName).trim(),\n                    first_name: firstName,\n                    last_name: lastName,\n                    roles: [\n                        \"subscriber\"\n                    ],\n                    capabilities: {},\n                    created_at: new Date().toISOString(),\n                    wp_synced: false // Flag to track if synced with WordPress\n                };\n                const token = Buffer.from(\"\".concat(email, \":\").concat(Date.now())).toString(\"base64\");\n                console.log(\"Local user created successfully:\", localUser);\n                return {\n                    success: true,\n                    user: localUser,\n                    token\n                };\n            }\n            if (response.status === 400) {\n                if (errorData.code === \"existing_user_email\") {\n                    return {\n                        success: false,\n                        error: \"An account with this email already exists\"\n                    };\n                } else if (errorData.code === \"existing_user_login\") {\n                    return {\n                        success: false,\n                        error: \"An account with this username already exists\"\n                    };\n                } else if (errorData.message) {\n                    return {\n                        success: false,\n                        error: errorData.message\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: errorData.message || \"Registration failed (\".concat(response.status, \")\")\n            };\n        }\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        return {\n            success: false,\n            error: \"Registration service unavailable. Please try again later.\"\n        };\n    }\n}\nasync function authenticateWordPressUser(username, password) {\n    try {\n        console.log(\"Attempting to authenticate user:\", username);\n        // Check if this is a valid email format\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(username)) {\n            return {\n                success: false,\n                error: \"Please enter a valid email address\"\n            };\n        }\n        // Create Basic Auth header with WordPress application password\n        const auth = Buffer.from(\"\".concat(process.env.WORDPRESS_API_USERNAME, \":\").concat(process.env.WORDPRESS_API_PASSWORD)).toString(\"base64\");\n        // Search for user by email in WordPress\n        const response = await fetch(\"\".concat(process.env.WORDPRESS_API_BASE, \"/users?search=\").concat(username), {\n            headers: {\n                \"Authorization\": \"Basic \".concat(auth),\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (response.ok) {\n            const users = await response.json();\n            const user = users.find((u)=>u.email === username);\n            if (user) {\n                // User found in WordPress\n                const token = Buffer.from(\"\".concat(username, \":\").concat(Date.now())).toString(\"base64\");\n                return {\n                    success: true,\n                    user: {\n                        id: user.id,\n                        username: user.username,\n                        email: user.email,\n                        name: user.name,\n                        first_name: user.first_name || \"\",\n                        last_name: user.last_name || \"\",\n                        roles: user.roles || [\n                            \"subscriber\"\n                        ],\n                        capabilities: user.capabilities || {}\n                    },\n                    token\n                };\n            }\n        }\n        // If user not found in WordPress, check if it's a local user\n        // For demo purposes, we'll simulate local user authentication\n        // In production, you would check against your local database\n        // For now, we'll create a mock local user for demonstration\n        // This allows users to login even if they're not in WordPress yet\n        const mockLocalUser = {\n            id: Date.now(),\n            username,\n            email: username,\n            name: \"Local User\",\n            first_name: \"Local\",\n            last_name: \"User\",\n            roles: [\n                \"subscriber\"\n            ],\n            capabilities: {}\n        };\n        const token = Buffer.from(\"\".concat(username, \":\").concat(Date.now())).toString(\"base64\");\n        console.log(\"Local user authentication successful:\", mockLocalUser);\n        return {\n            success: true,\n            user: mockLocalUser,\n            token\n        };\n    } catch (error) {\n        console.error(\"Authentication error:\", error);\n        return {\n            success: false,\n            error: \"Authentication service unavailable\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi93b3JkcHJlc3MtYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NPLE1BQU1BLHFCQUFxQix1Q0FBc0M7QUFFeEUsb0RBQW9EO0FBQzdDLGVBQWVDO0lBQ3BCLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sR0FBc0IsT0FBbkJILG9CQUFtQjtRQUNuRCxJQUFJRSxTQUFTRSxFQUFFLEVBQUU7WUFDZixPQUFPO2dCQUFFQyxTQUFTO1lBQUs7UUFDekIsT0FBTztZQUNMLE1BQU1DLFlBQVksTUFBTUosU0FBU0ssSUFBSTtZQUNyQyxPQUFPO2dCQUNMRixTQUFTO2dCQUNURyxPQUFPLHdCQUE2Q0YsT0FBckJKLFNBQVNPLE1BQU0sRUFBQyxPQUEwQyxPQUFyQ0gsVUFBVUksT0FBTyxJQUFJO1lBQzNFO1FBQ0Y7SUFDRixFQUFFLE9BQU9GLE9BQU87UUFDZCxPQUFPO1lBQ0xILFNBQVM7WUFDVEcsT0FBTyxvQ0FBMEMsT0FBTkE7UUFDN0M7SUFDRjtBQUNGO0FBRU8sZUFBZUcscUJBQ3BCQyxZQUFvQjtRQUNwQkMsT0FBQUEsaUVBQWUsR0FDZkMsVUFBQUEsaUVBQWtCO0lBRWxCLElBQUk7UUFDRixxQ0FBcUM7UUFDckMsTUFBTUMsbUJBQW1CLE1BQU1aLE1BQzdCLEdBQXlDUyxPQUF0Q1osb0JBQW1CLHFCQUFnQyxPQUFiWTtRQUczQyxJQUFJLENBQUNHLGlCQUFpQlgsRUFBRSxFQUFFO1lBQ3hCLE1BQU0sSUFBSVksTUFBTSw2QkFBeUQsT0FBNUJELGlCQUFpQkUsVUFBVTtRQUMxRTtRQUVBLE1BQU1DLGFBQWEsTUFBTUgsaUJBQWlCUixJQUFJO1FBRTlDLElBQUlXLFdBQVdDLE1BQU0sS0FBSyxHQUFHO1lBQzNCLE9BQU8sRUFBRTtRQUNYO1FBRUEsTUFBTUMsYUFBYUYsVUFBVSxDQUFDLEVBQUUsQ0FBQ0csRUFBRTtRQUVuQyw2QkFBNkI7UUFDN0IsTUFBTW5CLFdBQVcsTUFB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SUFBSXVCLEtBQUtzQyxHQUFHO1lBQ1p4QjtZQUNBQyxPQUFPRDtZQUNQSCxNQUFNO1lBQ05zQixZQUFZO1lBQ1pDLFdBQVc7WUFDWEMsT0FBTztnQkFBQzthQUFhO1lBQ3JCSyxjQUFjLENBQUM7UUFDakI7UUFFQSxNQUFNSCxRQUFRaEIsTUFBTUEsQ0FBQ0MsSUFBSSxDQUFDLEdBQWV0QixPQUFaYyxVQUFTLEtBQWMsT0FBWGQsS0FBS3NDLEdBQUcsS0FBTVgsUUFBUSxDQUFDO1FBRWhFakQsUUFBUXlDLEdBQUcsQ0FBQyx5Q0FBeUNpQztRQUVyRCxPQUFPO1lBQ0wzRixTQUFTO1lBQ1Q4RSxNQUFNYTtZQUNOZjtRQUNGO0lBRUYsRUFBRSxPQUFPekUsT0FBTztRQUNkYyxRQUFRZCxLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPO1lBQ0xILFNBQVM7WUFDVEcsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvd29yZHByZXNzLWFwaS50cz9lZTRkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgV29yZFByZXNzUG9zdCB7XG4gIGlkOiBudW1iZXJcbiAgdGl0bGU6IHtcbiAgICByZW5kZXJlZDogc3RyaW5nXG4gIH1cbiAgY29udGVudDoge1xuICAgIHJlbmRlcmVkOiBzdHJpbmdcbiAgfVxuICBleGNlcnB0OiB7XG4gICAgcmVuZGVyZWQ6IHN0cmluZ1xuICB9XG4gIGRhdGU6IHN0cmluZ1xuICBtb2RpZmllZDogc3RyaW5nXG4gIHNsdWc6IHN0cmluZ1xuICBsaW5rOiBzdHJpbmdcbiAgZmVhdHVyZWRfbWVkaWE6IG51bWJlclxuICBjYXRlZ29yaWVzOiBudW1iZXJbXVxuICB0YWdzOiBudW1iZXJbXVxuICBfZW1iZWRkZWQ/OiB7XG4gICAgJ3dwOmZlYXR1cmVkbWVkaWEnPzogQXJyYXk8e1xuICAgICAgc291cmNlX3VybDogc3RyaW5nXG4gICAgICBhbHRfdGV4dDogc3RyaW5nXG4gICAgfT5cbiAgICAnd3A6dGVybSc/OiBBcnJheTxBcnJheTx7XG4gICAgICBpZDogbnVtYmVyXG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHNsdWc6IHN0cmluZ1xuICAgICAgdGF4b25vbXk6IHN0cmluZ1xuICAgIH0+PlxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29yZFByZXNzQ2F0ZWdvcnkge1xuICBpZDogbnVtYmVyXG4gIG5hbWU6IHN0cmluZ1xuICBzbHVnOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBjb3VudDogbnVtYmVyXG59XG5cbmV4cG9ydCBjb25zdCBXT1JEUFJFU1NfQVBJX0JBU0UgPSAnaHR0cHM6Ly9yZW5hc3ByZXNzLmNvbS93cC1qc29uL3dwL3YyJ1xuXG4vLyBEZWJ1ZyBmdW5jdGlvbiB0byB0ZXN0IFdvcmRQcmVzcyBBUEkgY29ubmVjdGl2aXR5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdFdvcmRQcmVzc0FQSSgpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7V09SRFBSRVNTX0FQSV9CQVNFfS91c2Vycz9wZXJfcGFnZT0xYClcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBgV29yZFByZXNzIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9IC0gJHtlcnJvckRhdGEubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCBcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICBlcnJvcjogYFdvcmRQcmVzcyBBUEkgY29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YCBcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUG9zdHNCeUNhdGVnb3J5KFxuICBjYXRlZ29yeVNsdWc6IHN0cmluZyxcbiAgcGFnZTogbnVtYmVyID0gMSxcbiAgcGVyUGFnZTogbnVtYmVyID0gMTBcbik6IFByb21pc2U8V29yZFByZXNzUG9zdFtdPiB7XG4gIHRyeSB7XG4gICAgLy8gRmlyc3QsIGdldCB0aGUgY2F0ZWdvcnkgSUQgYnkgc2x1Z1xuICAgIGNvbnN0IGNhdGVnb3J5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke1dPUkRQUkVTU19BUElfQkFTRX0vY2F0ZWdvcmllcz9zbHVnPSR7Y2F0ZWdvcnlTbHVnfWBcbiAgICApXG4gICAgXG4gICAgaWYgKCFjYXRlZ29yeVJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjYXRlZ29yeTogJHtjYXRlZ29yeVJlc3BvbnNlLnN0YXR1c1RleHR9YClcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IGF3YWl0IGNhdGVnb3J5UmVzcG9uc2UuanNvbigpXG4gICAgXG4gICAgaWYgKGNhdGVnb3JpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2F0ZWdvcnlJZCA9IGNhdGVnb3JpZXNbMF0uaWRcbiAgICBcbiAgICAvLyBGZXRjaCBwb3N0cyBieSBjYXRlZ29yeSBJRFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtXT1JEUFJFU1NfQVBJX0JBU0V9L3Bvc3RzP2NhdGVnb3JpZXM9JHtjYXRlZ29yeUlkfSZwYWdlPSR7cGFnZX0mcGVyX3BhZ2U9JHtwZXJQYWdlfSZfZW1iZWQ9dHJ1ZWBcbiAgICApXG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggcG9zdHM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9zdHM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQWxsQ2F0ZWdvcmllcygpOiBQcm9taXNlPFdvcmRQcmVzc0NhdGVnb3J5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke1dPUkRQUkVTU19BUElfQkFTRX0vY2F0ZWdvcmllcz9wZXJfcGFnZT0xMDBgKVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGNhdGVnb3JpZXM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcmllczonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQb3N0KHNsdWc6IHN0cmluZyk6IFByb21pc2U8V29yZFByZXNzUG9zdCB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7V09SRFBSRVNTX0FQSV9CQVNFfS9wb3N0cz9zbHVnPSR7c2x1Z30mX2VtYmVkPXRydWVgXG4gICAgKVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHBvc3Q6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb3N0cyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBwb3N0cy5sZW5ndGggPiAwID8gcG9zdHNbMF0gOiBudWxsXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9zdDonLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJlY2VudFBvc3RzKFxuICBwZXJQYWdlOiBudW1iZXIgPSAxMCxcbiAgY2F0ZWdvcnlTbHVnPzogc3RyaW5nXG4pOiBQcm9taXNlPFdvcmRQcmVzc1Bvc3RbXT4ge1xuICB0cnkge1xuICAgIGxldCB1cmwgPSBgJHtXT1JEUFJFU1NfQVBJX0JBU0V9L3Bvc3RzP3Blcl9wYWdlPSR7cGVyUGFnZX0mb3JkZXJieT1kYXRlJm9yZGVyPWRlc2MmX2VtYmVkPXRydWVgXG4gICAgXG4gICAgLy8gSWYgY2F0ZWdvcnkgaXMgc3BlY2lmaWVkLCBmaWx0ZXIgYnkgY2F0ZWdvcnlcbiAgICBpZiAoY2F0ZWdvcnlTbHVnKSB7XG4gICAgICBjb25zdCBjYXRlZ29yeVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGAke1dPUkRQUkVTU19BUElfQkFTRX0vY2F0ZWdvcmllcz9zbHVnPSR7Y2F0ZWdvcnlTbHVnfWBcbiAgICAgIClcbiAgICAgIFxuICAgICAgaWYgKGNhdGVnb3J5UmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IGF3YWl0IGNhdGVnb3J5UmVzcG9uc2UuanNvbigpXG4gICAgICAgIGlmIChjYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1cmwgKz0gYCZjYXRlZ29yaWVzPSR7Y2F0ZWdvcmllc1swXS5pZH1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpXG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggcmVjZW50IHBvc3RzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlY2VudCBwb3N0czonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZWRJbWFnZVVybChwb3N0OiBXb3JkUHJlc3NQb3N0KTogc3RyaW5nIHtcbiAgaWYgKHBvc3QuX2VtYmVkZGVkPy5bJ3dwOmZlYXR1cmVkbWVkaWEnXT8uWzBdPy5zb3VyY2VfdXJsKSB7XG4gICAgcmV0dXJuIHBvc3QuX2VtYmVkZGVkWyd3cDpmZWF0dXJlZG1lZGlhJ11bMF0uc291cmNlX3VybFxuICB9XG4gIHJldHVybiAnL2FwaS9wbGFjZWhvbGRlci84MDAvNTAwJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zdEV4Y2VycHQocG9zdDogV29yZFByZXNzUG9zdCwgbWF4TGVuZ3RoOiBudW1iZXIgPSAxNTApOiBzdHJpbmcge1xuICAvLyBSZW1vdmUgSFRNTCB0YWdzIGFuZCBnZXQgY2xlYW4gdGV4dFxuICBjb25zdCBjbGVhblRleHQgPSBwb3N0LmV4Y2VycHQucmVuZGVyZWRcbiAgICAucmVwbGFjZSgvPFtePl0qPi9nLCAnJylcbiAgICAucmVwbGFjZSgvJlteO10rOy9nLCAnICcpXG4gICAgLnRyaW0oKVxuICBcbiAgaWYgKGNsZWFuVGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNsZWFuVGV4dFxuICB9XG4gIFxuICByZXR1cm4gY2xlYW5UZXh0LnN1YnN0cmluZygwLCBtYXhMZW5ndGgpLnJlcGxhY2UoL1xccytcXFMqJC8sICcnKSArICcuLi4nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRQb3N0RGF0ZShkYXRlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZylcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcbiAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgbW9udGg6ICdsb25nJyxcbiAgICBkYXk6ICdudW1lcmljJ1xuICB9KVxufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHByb2Nlc3MgV29yZFByZXNzIEFQSSByZXNwb25zZXNcbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzV29yZFByZXNzUG9zdChwb3N0OiBhbnkpOiBhbnkge1xuICByZXR1cm4ge1xuICAgIC4uLnBvc3QsXG4gICAgdGl0bGU6IHR5cGVvZiBwb3N0LnRpdGxlID09PSAnb2JqZWN0JyA/IHBvc3QudGl0bGUucmVuZGVyZWQgOiBwb3N0LnRpdGxlLFxuICAgIGNvbnRlbnQ6IHR5cGVvZiBwb3N0LmNvbnRlbnQgPT09ICdvYmplY3QnID8gcG9zdC5jb250ZW50LnJlbmRlcmVkIDogcG9zdC5jb250ZW50LFxuICAgIGV4Y2VycHQ6IHR5cGVvZiBwb3N0LmV4Y2VycHQgPT09ICdvYmplY3QnID8gcG9zdC5leGNlcnB0LnJlbmRlcmVkIDogcG9zdC5leGNlcnB0LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzV29yZFByZXNzUG9zdHMocG9zdHM6IGFueVtdKTogYW55W10ge1xuICByZXR1cm4gcG9zdHMubWFwKHByb2Nlc3NXb3JkUHJlc3NQb3N0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2F0ZWdvcnlOYW1lKHBvc3Q6IFdvcmRQcmVzc1Bvc3QpOiBzdHJpbmcge1xuICBpZiAocG9zdC5fZW1iZWRkZWQ/Llsnd3A6dGVybSddPy5bMF0pIHtcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gcG9zdC5fZW1iZWRkZWRbJ3dwOnRlcm0nXVswXVxuICAgIHJldHVybiBjYXRlZ29yaWVzWzBdPy5uYW1lIHx8ICdVbmNhdGVnb3JpemVkJ1xuICB9XG4gIHJldHVybiAnVW5jYXRlZ29yaXplZCdcbn1cblxuLy8gQ2F0ZWdvcnkgbWFwcGluZyBmb3IgdGhlIHNwZWNpZmljIGNhdGVnb3JpZXMgbWVudGlvbmVkXG5leHBvcnQgY29uc3QgQ0FURUdPUllfU0xVR1MgPSB7XG4gICdkYWlseS1uZXdzJzogJ2RhaWx5LW5ld3MnLFxuICAnY2hhcml0eSc6ICdjaGFyaXR5JywgXG4gICdzcG9ydHMnOiAnc3BvcnRzJyxcbiAgJ3dvbWFuJzogJ3dvbWFuJyxcbiAgJ3BvbGl0aWNhbC1uZXdzJzogJ3BvbGl0aWNhbC1uZXdzJ1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBDYXRlZ29yeVNsdWcgPSBrZXlvZiB0eXBlb2YgQ0FURUdPUllfU0xVR1NcblxuLy8gV29yZFByZXNzIEF1dGhlbnRpY2F0aW9uIEZ1bmN0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBXb3JkUHJlc3NVc2VyIHtcbiAgaWQ6IG51bWJlclxuICB1c2VybmFtZTogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGZpcnN0X25hbWU6IHN0cmluZ1xuICBsYXN0X25hbWU6IHN0cmluZ1xuICByb2xlczogc3RyaW5nW11cbiAgY2FwYWJpbGl0aWVzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW5cbiAgdXNlcj86IFdvcmRQcmVzc1VzZXJcbiAgdG9rZW4/OiBzdHJpbmdcbiAgZXJyb3I/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyV29yZFByZXNzVXNlcihcbiAgdXNlcm5hbWU6IHN0cmluZyxcbiAgZW1haWw6IHN0cmluZyxcbiAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgZmlyc3ROYW1lOiBzdHJpbmcsXG4gIGxhc3ROYW1lOiBzdHJpbmdcbik6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgdXNlciB3aXRoIFdvcmRQcmVzcyBBUEk6JywgeyB1c2VybmFtZSwgZW1haWwsIGZpcnN0TmFtZSwgbGFzdE5hbWUgfSlcbiAgICBcbiAgICAvLyBGaXJzdCwgdHJ5IHRvIGNyZWF0ZSB1c2VyIGluIFdvcmRQcmVzc1xuICAgIGNvbnN0IGF1dGggPSBCdWZmZXIuZnJvbShgJHtwcm9jZXNzLmVudi5XT1JEUFJFU1NfQVBJX1VTRVJOQU1FfToke3Byb2Nlc3MuZW52LldPUkRQUkVTU19BUElfUEFTU1dPUkR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtwcm9jZXNzLmVudi5XT1JEUFJFU1NfQVBJX0JBU0V9L3VzZXJzYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJhc2ljICR7YXV0aH1gLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgICBmaXJzdF9uYW1lOiBmaXJzdE5hbWUsXG4gICAgICAgIGxhc3RfbmFtZTogbGFzdE5hbWUsXG4gICAgICAgIHJvbGVzOiBbJ3N1YnNjcmliZXInXVxuICAgICAgfSlcbiAgICB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdXb3JkUHJlc3MgcmVnaXN0cmF0aW9uIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpXG5cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zdCB0b2tlbiA9IEJ1ZmZlci5mcm9tKGAke2VtYWlsfToke0RhdGUubm93KCl9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogdXNlckRhdGEuaWQsXG4gICAgICAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lLFxuICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgICAgICBuYW1lOiB1c2VyRGF0YS5uYW1lLFxuICAgICAgICAgIGZpcnN0X25hbWU6IHVzZXJEYXRhLmZpcnN0X25hbWUsXG4gICAgICAgICAgbGFzdF9uYW1lOiB1c2VyRGF0YS5sYXN0X25hbWUsXG4gICAgICAgICAgcm9sZXM6IHVzZXJEYXRhLnJvbGVzIHx8IFsnc3Vic2NyaWJlciddLFxuICAgICAgICAgIGNhcGFiaWxpdGllczogdXNlckRhdGEuY2FwYWJpbGl0aWVzIHx8IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHRva2VuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc29sZS5sb2coJ1dvcmRQcmVzcyByZWdpc3RyYXRpb24gZXJyb3IgcmVzcG9uc2U6JywgZXJyb3JEYXRhKVxuICAgICAgXG4gICAgICAvLyBJZiB1c2VyIGNyZWF0aW9uIGZhaWxzIGR1ZSB0byBwZXJtaXNzaW9ucywgY3JlYXRlIGEgbG9jYWwgdXNlclxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIGVycm9yRGF0YS5jb2RlID09PSAncmVzdF9jYW5ub3RfY3JlYXRlX3VzZXInKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXb3JkUHJlc3MgdXNlciBjcmVhdGlvbiBub3QgYWxsb3dlZCwgY3JlYXRpbmcgbG9jYWwgdXNlciBpbnN0ZWFkJylcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBsb2NhbCB1c2VyIHRoYXQgY2FuIGJlIHN5bmNlZCB3aXRoIFdvcmRQcmVzcyBsYXRlclxuICAgICAgICBjb25zdCBsb2NhbFVzZXIgPSB7XG4gICAgICAgICAgaWQ6IERhdGUubm93KCksXG4gICAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgbmFtZTogYCR7Zmlyc3ROYW1lfSAke2xhc3ROYW1lfWAudHJpbSgpLFxuICAgICAgICAgIGZpcnN0X25hbWU6IGZpcnN0TmFtZSxcbiAgICAgICAgICBsYXN0X25hbWU6IGxhc3ROYW1lLFxuICAgICAgICAgIHJvbGVzOiBbJ3N1YnNjcmliZXInXSxcbiAgICAgICAgICBjYXBhYmlsaXRpZXM6IHt9LFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB3cF9zeW5jZWQ6IGZhbHNlIC8vIEZsYWcgdG8gdHJhY2sgaWYgc3luY2VkIHdpdGggV29yZFByZXNzXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRva2VuID0gQnVmZmVyLmZyb20oYCR7ZW1haWx9OiR7RGF0ZS5ub3coKX1gKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCB1c2VyIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5OicsIGxvY2FsVXNlcilcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB1c2VyOiBsb2NhbFVzZXIsXG4gICAgICAgICAgdG9rZW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgaWYgKGVycm9yRGF0YS5jb2RlID09PSAnZXhpc3RpbmdfdXNlcl9lbWFpbCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0FuIGFjY291bnQgd2l0aCB0aGlzIGVtYWlsIGFscmVhZHkgZXhpc3RzJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckRhdGEuY29kZSA9PT0gJ2V4aXN0aW5nX3VzZXJfbG9naW4nKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdBbiBhY2NvdW50IHdpdGggdGhpcyB1c2VybmFtZSBhbHJlYWR5IGV4aXN0cydcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JEYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JEYXRhLm1lc3NhZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvckRhdGEubWVzc2FnZSB8fCBgUmVnaXN0cmF0aW9uIGZhaWxlZCAoJHtyZXNwb25zZS5zdGF0dXN9KWBcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnUmVnaXN0cmF0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJ1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlV29yZFByZXNzVXNlcihcbiAgdXNlcm5hbWU6IHN0cmluZyxcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBhdXRoZW50aWNhdGUgdXNlcjonLCB1c2VybmFtZSlcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdmFsaWQgZW1haWwgZm9ybWF0XG4gICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvXG4gICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QodXNlcm5hbWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzJ1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgQmFzaWMgQXV0aCBoZWFkZXIgd2l0aCBXb3JkUHJlc3MgYXBwbGljYXRpb24gcGFzc3dvcmRcbiAgICBjb25zdCBhdXRoID0gQnVmZmVyLmZyb20oYCR7cHJvY2Vzcy5lbnYuV09SRFBSRVNTX0FQSV9VU0VSTkFNRX06JHtwcm9jZXNzLmVudi5XT1JEUFJFU1NfQVBJX1BBU1NXT1JEfWApLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIFxuICAgIC8vIFNlYXJjaCBmb3IgdXNlciBieSBlbWFpbCBpbiBXb3JkUHJlc3NcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7cHJvY2Vzcy5lbnYuV09SRFBSRVNTX0FQSV9CQVNFfS91c2Vycz9zZWFyY2g9JHt1c2VybmFtZX1gLFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmFzaWMgJHthdXRofWAsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc3QgdXNlciA9IHVzZXJzLmZpbmQoKHU6IGFueSkgPT4gdS5lbWFpbCA9PT0gdXNlcm5hbWUpXG5cbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIC8vIFVzZXIgZm91bmQgaW4gV29yZFByZXNzXG4gICAgICAgIGNvbnN0IHRva2VuID0gQnVmZmVyLmZyb20oYCR7dXNlcm5hbWV9OiR7RGF0ZS5ub3coKX1gKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgICBuYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICBmaXJzdF9uYW1lOiB1c2VyLmZpcnN0X25hbWUgfHwgJycsXG4gICAgICAgICAgICBsYXN0X25hbWU6IHVzZXIubGFzdF9uYW1lIHx8ICcnLFxuICAgICAgICAgICAgcm9sZXM6IHVzZXIucm9sZXMgfHwgWydzdWJzY3JpYmVyJ10sXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHVzZXIuY2FwYWJpbGl0aWVzIHx8IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdXNlciBub3QgZm91bmQgaW4gV29yZFByZXNzLCBjaGVjayBpZiBpdCdzIGEgbG9jYWwgdXNlclxuICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCB3ZSdsbCBzaW11bGF0ZSBsb2NhbCB1c2VyIGF1dGhlbnRpY2F0aW9uXG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IHdvdWxkIGNoZWNrIGFnYWluc3QgeW91ciBsb2NhbCBkYXRhYmFzZVxuICAgIFxuICAgIC8vIEZvciBub3csIHdlJ2xsIGNyZWF0ZSBhIG1vY2sgbG9jYWwgdXNlciBmb3IgZGVtb25zdHJhdGlvblxuICAgIC8vIFRoaXMgYWxsb3dzIHVzZXJzIHRvIGxvZ2luIGV2ZW4gaWYgdGhleSdyZSBub3QgaW4gV29yZFByZXNzIHlldFxuICAgIGNvbnN0IG1vY2tMb2NhbFVzZXIgPSB7XG4gICAgICBpZDogRGF0ZS5ub3coKSxcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgZW1haWw6IHVzZXJuYW1lLFxuICAgICAgbmFtZTogJ0xvY2FsIFVzZXInLFxuICAgICAgZmlyc3RfbmFtZTogJ0xvY2FsJyxcbiAgICAgIGxhc3RfbmFtZTogJ1VzZXInLFxuICAgICAgcm9sZXM6IFsnc3Vic2NyaWJlciddLFxuICAgICAgY2FwYWJpbGl0aWVzOiB7fVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB0b2tlbiA9IEJ1ZmZlci5mcm9tKGAke3VzZXJuYW1lfToke0RhdGUubm93KCl9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0xvY2FsIHVzZXIgYXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bDonLCBtb2NrTG9jYWxVc2VyKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdXNlcjogbW9ja0xvY2FsVXNlcixcbiAgICAgIHRva2VuXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGVycm9yOicsIGVycm9yKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gc2VydmljZSB1bmF2YWlsYWJsZSdcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJXT1JEUFJFU1NfQVBJX0JBU0UiLCJ0ZXN0V29yZFByZXNzQVBJIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3VjY2VzcyIsImVycm9yRGF0YSIsImpzb24iLCJlcnJvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJmZXRjaFBvc3RzQnlDYXRlZ29yeSIsImNhdGVnb3J5U2x1ZyIsInBhZ2UiLCJwZXJQYWdlIiwiY2F0ZWdvcnlSZXNwb25zZSIsIkVycm9yIiwic3RhdHVzVGV4dCIsImNhdGVnb3JpZXMiLCJsZW5ndGgiLCJjYXRlZ29yeUlkIiwiaWQiLCJjb25zb2xlIiwiZmV0Y2hBbGxDYXRlZ29yaWVzIiwiZmV0Y2hQb3N0Iiwic2x1ZyIsInBvc3RzIiwiZmV0Y2hSZWNlbnRQb3N0cyIsInVybCIsImdldEZlYXR1cmVkSW1hZ2VVcmwiLCJwb3N0IiwiX2VtYmVkZGVkIiwic291cmNlX3VybCIsImdldFBvc3RFeGNlcnB0IiwibWF4TGVuZ3RoIiwiY2xlYW5UZXh0IiwiZXhjZXJwdCIsInJlbmRlcmVkIiwicmVwbGFjZSIsInRyaW0iLCJzdWJzdHJpbmciLCJmb3JtYXRQb3N0RGF0ZSIsImRhdGVTdHJpbmciLCJkYXRlIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInllYXIiLCJtb250aCIsImRheSIsInByb2Nlc3NXb3JkUHJlc3NQb3N0IiwidGl0bGUiLCJjb250ZW50IiwicHJvY2Vzc1dvcmRQcmVzc1Bvc3RzIiwibWFwIiwiZ2V0Q2F0ZWdvcnlOYW1lIiwibmFtZSIsIkNBVEVHT1JZX1NMVUdTIiwicmVnaXN0ZXJXb3JkUHJlc3NVc2VyIiwidXNlcm5hbWUiLCJlbWFpbCIsInBhc3N3b3JkIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJsb2ciLCJhdXRoIiwiQnVmZmVyIiwiZnJvbSIsInByb2Nlc3MiLCJlbnYiLCJXT1JEUFJFU1NfQVBJX1VTRVJOQU1FIiwiV09SRFBSRVNTX0FQSV9QQVNTV09SRCIsInRvU3RyaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsInJvbGVzIiwidXNlckRhdGEiLCJ0b2tlbiIsIm5vdyIsInVzZXIiLCJjYXBhYmlsaXRpZXMiLCJjb2RlIiwibG9jYWxVc2VyIiwiY3JlYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwid3Bfc3luY2VkIiwiYXV0aGVudGljYXRlV29yZFByZXNzVXNlciIsImVtYWlsUmVnZXgiLCJ0ZXN0IiwidXNlcnMiLCJmaW5kIiwidSIsIm1vY2tMb2NhbFVzZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/wordpress-api.ts\n"));

/***/ })

});